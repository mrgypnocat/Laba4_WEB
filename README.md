# Laba4_WEB

Будет больно, но ради этого и живем

- [x] Уровень back-end должен быть основан на JavaEE (необходимо использовать EJB)
- [x] Уровень front-end должен быть построен на React + Redux (необходимо использовать ES6 и JSX) с использованием набора компонентов React Toolbox
- [x] Взаимодействие между уровнями back-end и front-end должно быть организовано посредством REST API

Приложение включает в себя две страницы: стартовую и основную. Обе страницы должны быть адаптированы для отображения в 3 режимах:
- [x] "Десктопный" - для устройств, ширина экрана которых равна или превышает 1169 пикселей 
- [x] "Планшетный" - для устройств, ширина экрана которых равна или превышает 708, но меньше 1169 пикселей 
- [x] "Мобильный" - для устройств, ширина экрана которых меньше 708 пикселей 
    
Стартовая страница должна содержать следующие элементы:
- [x] "Шапку", содержащую ФИО студента, номер группы и номер варианта
- [x] Форму для ввода логина и пароля 
- [x] Информация о зарегистрированных в системе пользователях должна храниться в отдельной таблице БД 
- [x] Пароль должен храниться в виде хэш-суммы
- [x] Доступ неавторизованных пользователей к основной странице приложения должен быть запрещен 

Основная страница приложения должна содержать следующие элементы:
- [x] Набор полей ввода для задания координат точки и радиуса области в соответствии с вариантом задания:
    - [x] Dropdown {'-4','-3','-2','-1','0','1','2','3','4'} для координаты по оси X
    - [x] Input (-3 ... 5) для координаты по оси Y
    - [x] Dropdown {'-4','-3','-2','-1','0','1','2','3','4'} для задания радиуса области 
- [x] Если поле ввода допускает ввод заведомо некорректных данных (таких, например, как буквы в координатах точки или отрицательный радиус), то приложение должно осуществлять их валидацию 
- [x] Динамически обновляемую картинку, изображающую область на координатной плоскости в соответсвии с номером варианта и точки, координаты которых были заданы пользователем.
- [x] Клик по картинке должен инициировать сценарий, осуществляющий определение координат новой точки и отправку их на сервер для проверки ее попадания в область. 
- [x] Цвет точек должен зависить от факта попадания/непопадания в область
- [x] Смена радиуса также должна инициировать перерисовку картинки
- [x] Таблицу со списком результатов предыдущих проверок
- [x] Ссылку, по которой аутентифицированный пользователь может закрыть свою сессию и вернуться на стартовую страницу приложения
 
Дополнительные требования к приложению:

- [x] Все результаты проверки должны сохраняться в базе данных под управлением СУБД PostgreSQL 
- [x] Для доступа к БД необходимо использовать JPA

# Вопросы к защите лабораторной работы

## 1. Платформа Java EE. Спецификации и их реализации.

Java EE — это платформа, построенная на основе Java SE, которая предоставляет API и среду времени выполнения для разработки и запуска крупномасштабных, многоуровневых, масштабируемых, надежных и безопасных сетевых приложений.

Подобные приложения называют корпоративными (Enterprise applications), так как они решают проблемы, с которыми сталкиваются большие бизнесы. 

Java EE представляет из себя набор спецификаций и документации, описывающий архитектуру серверной платформы для задач средних и крупных предприятий.
Сервер приложений Java EE (часто называемый контейнером) — это реализация системы в соответствии со спецификацией, обеспечивающая работу модулей с логикой конкретного приложения.

Деление на платформы (Java SE, Java EE, Java Card ...) появилось в Java EE 6 и позволяет сделать более «лёгкими» приложения, которым не нужен полный стек технологий Java EE. Существует только 2 профиля — Full и Web. 	Сервер приложений может реализовывать спецификации не всей платформы, а конкретного профиля.

###Отличие Spring от JavaEE

Конкурентном Java EE считается Spring Framework. Если взглянуть на развитие двух данных платформ, выходит интересная картина. Первые версии Java EE были созданы при участии IBM. Они вышли крутыми, но неповоротливыми, тяжеловесными, неудобными в использовании. Разработчики плевались из-за необходимости поддерживать большое количество конфигурационных файлов и из-за прочих причин, усложняющих разработку.

В то же время на свет появился Spring IoC. Это была маленькая, красивая и приятная в обращении библиотека. В ней также использовался конфигурационный файл, но в отличии от Java EE, он был один. Простота Spring привела к тому, что практически все стали использовать данный фреймворк в своих проектах. 

А далее Spring и Java EE начали свой путь к одному и тому же, но с разных концов. Компания Pivotal Software, разработчик Spring, стали выпускать проект за проектом, чтобы покрыть все возможные и невозможные потребности Java-разработчиков. Постепенно то, что раньше называлось Spring, сначала стало одним из проектов, а потом и вовсе слилось с несколькими другими проектами в Spring Core. Все это привело к неминуемому усложнению Spring по сравнению с тем, каким он был изначально. Со временем следить за всем клубком зависимостей спринга стало уж совсем сложно, и возникла потребность в отдельной библиотеке, которая стала бы загружать и запускать все сама (сейчас где-то икнул так горячо любимый Spring Boot).

Все это время JCP работал над одним — добиться максимального упрощения всего, что только можно внутри Java EE. В итоге в современном EJB для описания бина достаточно указать одну аннотацию над классом, что предоставляет разработчику доступ ко всей мощи технологии Enterprise Java Beans. И подобные упрощения затронули каждую спецификацию внутри Java EE. 

В итоге по функционалу Spring и Java EE примерно разделяют паритет. Где-то что-то лучше, где-то что-то хуже, но если смотреть глобально, больших различий нет. То же самое касается сложности работы. И Spring, и Java EE являются превосходными инструментами. Пожалуй, лучшими из того, что сейчас есть, для построения корпоративных сетевых приложений на языке Java. 

!! Однако, Java EE может работать в общем случае только в рамках Enterprise Application Server’a (Tomcat таковым не является), а приложение на Spring стеке может работать на чем угодно (на том же Tomcat), и даже вообще без сервера (так как запустит его внутри себя самостоятельно).

!! Это делает Spring идеальным инструментом для разработки небольших приложений с GUI на Front-end или для микросервисной архитектуры. Но отказ от зависимости от серверов приложений отрицательно сказался на масштабируемости Spring-приложений.

А Java EE хорошо подходит для реализации масштабируемого монолитного кластерного приложения.


Пример Web profile: Tomcat

Пример Full profile: Glassfish

### Основные концепции

- Приложения строятся из компонентов, работающих под управлением контейнеров.
- Используются следующие принципы:
    - Inversion of Control (IoC) + Contexts & Dependency Injection (CDI).
    - Location Transparency.

https://javarush.ru/groups/posts/2637-vvedenie-v-java-ee - классное объяснение 


https://ru.photo-555.com/2403908-java-ee-interview-questions - вопросы с собеса

## 2. Принципы IoC, CDI и Location Transpanency. Компоненты и контейнеры.

Есть такая штука - JNDI - набор API, позволяющий доставать объекты из контейнера по их именам. По сути, это замена обращению по ссылкам, и благодаря этому легко реализуется Dependency Lookup и Dependency Injection. Хранение объектов в таком случае можно представить как Map, где ключи - это имена, а значения - нужные объекты (например, ссылки на них).

#### Два варианта использования JNDI:

- CDI (аннотации) — работает только в managed компонентах. 
- Прямой вызов API — работает везде.

```java
// Пример получения ссылки на JDBC datasource. DataSource dataSource = null;
public class JNDI { 

public void jndi() {
  try {
   // Инициализируем контекст по умолчанию. 
   Context context = new InitialContext(); 
   dataSource = (DataSource) context.lookup("Database"); 
  } catch (NamingException e) {
    // Ссылка не найдена
  }
}


}
```

### IoC - Inversion of Control (применительно к Java EE):
- Жизненным циклом компонента управляет контейнер (а не программист).
- Объекты создает не программист (используя new), а контейнер IoC. Применяется далеко не ко всем объектам в приложении, а только к  управляемым (в Spring это классы с аннотациями @Component, @Service и т.д., в EJB — бобы @Stateless, @Stateful, @MessageDriven).
- За взаимодействие между компонентами отвечает тоже контейнер.

### CDI — Contexts and Dependency Injection (позволяет снизить (или совсем убрать) зависимость компонента от контейнера):
как бы компонент и так зависит от контейнера, так как тот его порождает, но тут о другом: __программист, когда пишет компонент, он не зависит от API, предоставляемых контейнером__

- Не требуется реализации каких-либо интерфейсов. 
- Не нужны прямые вызовы API.
- Реализуется через аннотации.

Пример CDI (JSF Managed Bean):

```java
@ManagedBean(name="message")
@SessionScoped
public class MessageBean implements Serializable {
   //business logic and whatever methods
}


@ManagedBean
@SessionScoped
public class HelloBean implements Serializable {

   @ManagedProperty(value="#{message}") //ЭТО И ЕСТЬ CDI
   private MessageBean messageBean;

   //must povide the setter method
   public void setMessageBean(MessageBean messageBean) {
this.messageBean = messageBean; }
}
```
#### Еще одна интерпретация CDI

Вместо построения зависимостей в компоненте, где они нужны:

```java
public class Something {
  private Dependency dependency = new Dependency();
}
```
Мы принимаем их извне, что избавляет компонент от необходимости управлять ими:

```java
public class Something {
  private Dependency dependency;

  public Something (Dependency dependency) {
    this.dependency = dependency;
  }
} 
```
Чтобы нам не пришлось вручную собирать все зависимости для создания компонентов, контейнер IoC предоставляет возможность внедрения инстанций в поля, помеченные специальной аннотацией:
```java
public class SomethingDI {
  @Autowired private Dependency dependency; // Spring
  @EJB private EjbDependency ejbDependency; // EJB
}
```



### Location Transparency - прозрачность местонахождения - это что-то вроде паттерна

Инфраструктура завязана на RMI (Java API, позволяющий вызывать методы удаленных объектов)

Благодаря CDI не важно, где физически расположен вызываемый компонент — за его вызов отвечает контейнер.

Клиент имеет прокси, обращается с ней как с нужным объектом. Прокси перенаправляет его вызовы куда следует: если нужный компонент находится локально, идёт к нему обращение по ссылке; если удалённо (в другой JVM) - необходима сериализация передаваемых данных.

### Компоненты и контейнеры

Приложение состоит из компонентов и контейнера, управляющего жизненным циклом компонентов. Пример: Servlet - компонент, Glassfish - контейнер.

Голая Java EE — это просто набор спецификаций. 

Данные спецификации реализуют различные Java EE сервера.

Java EE сервер — это серверное приложение, которое реализует API-интерфейсы платформы Java EE и предоставляет стандартные службы Java EE. Серверы Java EE иногда называют серверами приложений. Данные сервера могут содержать в себе компоненты приложения, каждый из которых соответствует своему уровню в многоуровневой иерархии. Сервер Java EE предоставляет этим компонентам различные сервисы в форме контейнера.

Контейнеры — это интерфейс между размещенными на них компонентами и низкоуровневыми платформо-независимыми функциональными возможностями, поддерживающими компонент.  

Контейнеры предоставляют размещенным на них компонентам определенные службы. Например, управление жизненным циклом разработки, внедрение зависимости, параллельный доступ и т. д. Контейнеры скрывают техническую сложность и повышают мобильность.

#### В Java EE существует четыре различные типа контейнеров:

- Контейнеры апплетов выполняются большинством браузеров. При разработке апплетов можно сконцентрироваться на визуальной стороне приложения, в то время как контейнер обеспечивает безопасную среду.
- Контейнер клиентского приложения (ACC) включает набор Java-классов, библиотек и других файлов, необходимых для реализации в приложениях Java SE таких возможностей, как внедрение, управление безопасностью и служба именования.
- Веб-контейнер предоставляет базовые службы для управления и исполнения веб-компонентов (сервлетов, компонентов EJB Lite, страниц JSP, фильтров, слушателей, страниц JSF и веб-служб). Он отвечает за создание экземпляров, инициализацию и вызов сервлетов, а также поддержку протоколов HTTP и HTTPS. Этот контейнер используется для подачи веб-страниц к клиент-браузерам.
- EJB (Enterprise Java Bean) контейнер отвечает за управление и исполнение компонентов модели EJB, содержащих уровень бизнес-логики приложения. Он создает новые сущности компонентов EJB, управляет их жизненным циклом и обеспечивает реализацию таких сервисов, как транзакция, безопасность, параллельный доступ, распределение, служба именования либо возможность асинхронного вызова. 

#### Также в Java EE выделяют четыре типа компонентов, которые должна поддерживать реализация Java EE спецификации:

- Апплеты — это приложения из графического пользовательского интерфейса (GUI), выполняемые в браузере. Они задействуют насыщенный интерфейс Swing API для производства мощных пользовательских интерфейсов.
- Приложениями называются программы, выполняемые на клиентской стороне. Как правило, они относятся к графическому пользовательскому интерфейсу (GUI) и применяются для пакетной обработки.
- Веб-приложения (состоят из сервлетов и их фильтров, слушателей веб-событий, страниц JSP и JSF) — выполняются в веб-контейнере и отвечают на запросы HTTP от веб-клиентов. Сервлеты также поддерживают конечные точки веб-служб SOAP и RESTful.
- Корпоративные приложения (созданные с помощью технологии Enterprise Java Beans, службы сообщений Java Message Service, интерфейса Java API для транзакций, асинхронных вызовов, службы времени) выполняются в контейнере EJB. Управляемые контейнером компоненты EJB служат для обработки транзакционной бизнес-логики. Доступ к ним может быть как локальным, так и удаленным по протоколу RMI (или HTTP для веб-служб SOAP и RESTful).

Апплета: 

Но до сих пор эти надежды не сбылись. Проведенный недавно опрос, касающийся использования апплетов Java, показал, что они применяются менее чем на 2% из 500 самых популярных Web-сайтов. Почему? Некоторые разработчики неверно оценили накладные расходы при интерпретации байт-кода в виртуальной машине Java. У других множество нареканий вызывает защита, основанная на принципе (sandbox), который не позволяет Java использовать в полной мере локальные и удаленные службы. Третьи отмечают различия между виртуальными машинами основных браузеров, имеющихся на рынке. Так или иначе по прошествии пяти лет апплеты не оправдали ожиданий, и Web-приложения на базе HTML не были вытеснены Web-приложениями с равным уровнем переносимости и мобильности, но функционально более мощным графическим пользовательским интерфейсом.
"богатому графическому пользовательскому интерфейсу" не было визуальной среды разработки. А программировать графику вручную - задача рутинная для программиста и ненужная для дизайнера. %)

![alt text](resources/architectureJavaEE.png "Типичная архитектура Java EE приложения")

## 3. Управление жизненным циклом компонентов. Дескрипторы развёртывания.

По большей части, жизненным циклом компонентов управляет контейнер. Тем не менее, есть возможность влиять на этот процесс с помощью аннотаций / xml / прочих файлов настроек. Дескрипторы - это как раз такие файлы (в том числе xml). В них можно задавать свойства используемых в приложении компонентов: имена, ссылки, параметры. Также можно настраивать то, как итоговое приложение будет собираться и как оно будет взаимодействовать с внешним миром.

Дескриптор развёртывания - конфигурационный файл артефакта. Дескриптор развёртывания описывает то, как компонент, модуль или приложение (такое, как веб-приложение или приложение предприятия) должно быть развёрнуто

Примеры дескрипторов развёртывания:
- web.xml - дескриптор развёртывания веб-приложений (упаковываемых обычно в .war архивы)
- ejb-jar.xml - дескриптор развёртывания EJB-приложения	
- application.xml - дескриптор развёртывания приложения, использующего несколько web.xml / ejb-jar.xml

## 4. Java EE API. Виды компонентов. Профили платформы Java EE.

Деление на платформы (Java SE, Java EE, Java Card ...) появилось в Java EE 6 и позволяет сделать более «лёгкими» приложения, которым не нужен полный стек технологий Java EE. Существует только 2 профиля — Full и Web. 	Сервер приложений может реализовывать спецификации не всей платформы, а конкретного профиля.

Пример Web profile: Tomcat
Пример Full profile: Glassfish

Виды компонентов: 
- веб-компоненты (сервлеты, jsp, ...) - формируют содержимое представления
- Java-бины (POJO, ManagedBean, EJB) - позволяют изменять данные и осуществлять их временное хранение, взаимодействовать с базами данных и веб-службами, а также отображать содержимое в ответ на запросы клиентов.

## 5. Компоненты EJB. Stateless & Stateful Session Beans. EJB Lite и EJB Full.

EJB — технология разработки серверных компонентов,
реализующих бизнес-логику.

Особенности EJB:
- Возможность локального и удалённого доступа.
- Возможность доступа через JNDI или Dependency
Injection.
- Поддержка распределённых транзакций (с помощью
JTA).
- Поддержка событий.
- Жизненным циклом управляет EJB-контейнер (в составе
сервера приложений).

Компонентная модель EJB:

- EJB-компоненты инкапсулируются контейнером.
- Контейнер предоставляет клиентам проксиобъекты (proxy objects) для доступа к EJB компонентам.
- Прокси-объекты реализуют бизнес-интерфейсы
(Business Interfaces).
- Клиенты вызывают методы бизнесинтерфейсов.

Sessions Beans:
- Предназначены для синхронной обработки вызовов.
- Вызываются посредством обращения через API.
- Могут вызываться локально или удалённо.
- Могут быть endpoint'ами для веб-сервисов.
- CDI — аннотация @EJB.
- Не обладают свойством персистентности. (Персистентность в программировании означает способность состояния существовать дольше, чем процесс, создавший его)
- Можно формировать пулы бинов (за
исключением @Singleton).

Stateless Session Beans:

- Не сохраняют состояние между
последовательными обращениями клиента.
- Нет привязки к конкретному клиенту.
- Хорошо масштабируются.
- Объявление — аннотация @Stateless.

```java
package converter.ejb;
import java.math.BigDecimal;
import javax.ejb.*;
@Stateless
public class ConverterBean {
 private BigDecimal yenRate = new BigDecimal("83.0602");
 private BigDecimal euroRate = new BigDecimal("0.0093016");
 public BigDecimal dollarToYen(BigDecimal dollars) {
 BigDecimal result = dollars.multiply(yenRate);
 return result.setScale(2, BigDecimal.ROUND_UP);
 }
 public BigDecimal yenToEuro(BigDecimal yen) {
 BigDecimal result = yen.multiply(euroRate);
 return result.setScale(2, BigDecimal.ROUND_UP);
 }
}
```

Stateful Session Beans:

- «Привязываются» к конкретному клиенту.
- Можно сохранять контекст в полях класса.
- Масштабируются хуже, чем @Stateless.
- Объявление — аннотация @Stateful.

```java
@Stateful
@StatefulTimeout(unit = TimeUnit.MINUTES, value = 20)
public class CartBean implements Cart {
@PersistenceContext(unitName = "pu", type = PersistenceContextType.EXTENDED)
private EntityManager entityManager;
private List products;

@PostConstruct
private void initializeBean(){
products = new ArrayList<>();
}

@Override
public void addProductToCart(Product product) {
products.add(product);
}

@Override
@TransactionAttribute(TransactionAttributeType.REQUIRED)
public void checkOut() {
for(Product product : products){
entityManager.persist(product);
}
products.clear();
}
}
```
Singleton Session Beans:
- Контейнер гарантирует существование строго
одного экземпляра такого бина.
- Объявление — аннотация @Singleton.
+ Один корпоративный компонент должен быть доступен нескольким потокам одновременно. 
+ Приложение нуждается в корпоративном Бобе для выполнения задач на запуск и завершение работы приложения.

Требования к классам Session Beans:

- Должен быть public классом верхнего уровня.
- Не должен быть final и/или abstract.
- Должен иметь public конструктор без
параметров.
- Не должен переопределять метод finalize().
- Должен реализовывать все методы бизнесинтерфейса(-ов).


В плюс к этому ещё есть пулы экземпляров бинов. 

Так как клиенты обращаются к проксям, реализующим бизнес-интерфейс, а с реальными объектами бинов дел не имеют, с их жизненным циклом можно вытворять разные штуки. Вот что происходит для каждого из трёх видов сессионных бинов:
- Stateful - у каждого клиента своя прокси, ведущая на свой и только свой экземпляр бина, потому что клиенту важно состояние его бина
- Stateless - у каждого клиента один и тот же интерфейс, который каким-то образом уводит пользователя к одному из экземпляров бина из пула
- Singleton - единый интерфейс и единый экземпляр заставят вас поразвлекаться с concurrency

Message driven beans выполняют метод в ответ на получение сообщения из определенной очереди JMS.

Аннотация @EJB служит для CDI и предоставляет клиентам не сам объект, а прокси, через который можно получить доступ к методам бизнес-интерфейсов. Может осуществляться доступ как к локальным, так и удаленным (в другой JVM) объектам.

Stateless or Singleton:

Я бы выбрал Stateless - сервер может генерировать множество экземпляров bean-компонента и обрабатывать входящие запросы параллельно.

Синглтон звучит как потенциальное узкое место - значение @Lock по умолчанию - @Lock (WRITE), но может быть изменено на @Lock (READ) для компонента или отдельных методов.

@Stateless позволит вам иметь несколько копий, готовых для обработки в JVM (столько, сколько позволяет память и размер пула), где, как @Singleton, в JVM есть только одна копия, даже если одна может поддерживать несколько параллельных потоков, работающих против нее.

С точки зрения производительности @Singleton было бы лучше, при условии, что используемые ресурсы позволяют длительный доступ. Однако в распределенной среде иногда происходят плохие вещи, например, могут выйти из строя ссылки базы данных или сети.

С @Stateless бином доступ более недолговечный. Кроме того, в случае сбоя он просто возродится и попытается установить новое соединение с ресурсом. Если что-то подобное происходит с синглтоном, то синглтон должен обработать его, не требуя перезапуска приложения, потому что @PostConstruct вызывается только один раз для каждой JVM.

Я бы предпочел немного отказоустойчивости по сравнению с производительностью в большинстве ситуаций, особенно в системах, которые я не контролирую.


## 6. Работа с электронной почтой в Java EE. JavaMail API.

JavaMail API - фреймворк для работы с электронной почтой в Java с поддержкой протоколов SMTP, MIME, POP и некоторые другие.
Предоставляется следующее API из пакета javax.mail:
Session - класс, открывающий дверь в мир JavaMail 
Message - абстрактный класс (используются его наследники, 
например MimeMessage)
Address - абстрактный класс
Authenticator - абстрактный класс для защиты сообщений на сервере
Transport
Store
Folder
Пример кода:
```java
	// Recipient's email ID needs to be mentioned.
      String to = "destinationemail@gmail.com";

      // Sender's email ID needs to be mentioned
      String from = "fromemail@gmail.com";
      final String username = "manishaspatil";//change accordingly
      final String password = "******";//change accordingly

      // Assuming you are sending email through relay.jangosmtp.net
      String host = "relay.jangosmtp.net";

      Properties props = new Properties();
      props.put("mail.smtp.auth", "true");
      props.put("mail.smtp.starttls.enable", "true");
      props.put("mail.smtp.host", host);
      props.put("mail.smtp.port", "25");

      // Get the Session object.
      Session session = Session.getInstance(props,
         new javax.mail.Authenticator() {
            protected PasswordAuthentication getPasswordAuthentication() {
               return new PasswordAuthentication(username, password);
	   }
         });

      try {
	   // Create a default MimeMessage object.
	   Message message = new MimeMessage(session);
	
	   // Set From: header field of the header.
	   message.setFrom(new InternetAddress(from));
	
	   // Set To: header field of the header.
	   message.setRecipients(Message.RecipientType.TO,
               InternetAddress.parse(to));
	
	   // Set Subject: header field
	   message.setSubject("Testing Subject");
	
	   // Now set the actual message
	   message.setText("Hello, this is sample for to check send " +
		"email using JavaMailAPI ");

	   // Send message
	   Transport.send(message);

	   System.out.println("Sent message successfully....");

      } catch (MessagingException e) {
         throw new RuntimeException(e);
      }
```




## 7. JMS. Реализация очередей сообщений. Способы доставки сообщений до клиента. Message-Driven Beans.

### JMS

JMS, Java Message Service - это Java API (то есть набор интерфейсов и классов) для работы с Message-Oriented Middleware, изначально разработанная компанией Sun, чтобы предоставить разработчикам создавать гибкие и слабосвязанные приложения с использованием асинхронного обмена данными между приложениями (клиентами/серверами) через посредника. Асинхронность - это главная причина создания и использования JMS.

Данный набор определен в пакете javax.jms в дереве пакетов J2EE. JMS поддерживает две модели обмена сообщениями: point-to-point(точка - точка) и publish-subscribe(издатель-подписчик).

### MOM

MOM, Message-Oriented Middleware (промежуточное программное обеспечение) - подпрограммное обеспечение промежуточного слоя, ориентированное на обмен сообщениями в распределённом окружении. Прежде всего предназначено для реализации отложенного обмена сообщениями, на основе которого и строится Messaging System.

В отличие от традиционных систем, &nbsp;в Messaging System приложения общаются не напрямую, а посредством MOM. Если один компонент системы хочет послать сообщение другому компоненту, он посылает данное сообщение MOM, а MOM затем пересылает его адресату.

### Способы доставки сообщений до клиента

Существует 2 модели:
- Модель Точка-Точка (Point-to-Point, P2P) - в этой модели место назначения, используемое для хранения сообщений, называется очередью. Объект Queue. В этой модели один клиент помещает сообщение в очередь, а другой получает сообщение. Как только получение сообщения подтверждено, поставщик сообщений удаляет его из очереди.
- Модель Подписчик-Издатель (Publisher-Subscriber) - место назначения называется темой. Объект Topic. При использовании данной модели клиент публикует сообщение в теме и все абоненты этой темы получают сообщение.

https://jsehelper.blogspot.com/2016/12/jms.html
_____

Java Message Service — стандарт для асинхронного распределенного взаимодействия программных компонентов (которые могут находиться на одном компьютере, в одной локальной сети, или быть связаны через Интернет) путем рассылки сообщений.

JMS поддерживает две модели коммуникации: point-to-point и publish-subscribe (pubsub).

В point-to-point сообщения от разных отправителей адресуются определенной очереди, к которой подключаются клиенты. При этом для каждого сообщения гарантируется, что оно будет доставлено одному и только одному клиенту.

В pubsub сообщения адресуются определенному topic'у, на которые подписываются клиенты. Каждое сообщение может быть получено несколькими клиентами или не получено вообще, если подписчиков на момент доставки не было.

Существует несколько реализаций JMS провайдеров (RabbitMQ, Open Message Queue, ...) - эти решения шире

### Message-Driven Beans
 
MDB — это компоненты, логика которых является
реакцией на события, происходящие в системе.
Особенности MDB:
- Реализуют интерфейс слушателя соответствующего
типа сообщений (например, JMS).
- Нет возможности вызова методов «напрямую».
- Нет локальных и удалённых интерфейсов.
- Контейнер может создавать пулы MDB.
- При развёртывании MDB нужно регистрировать в
качестве получателей сообщений.

### Пример MDB

```java
import javax.ejb.*;
import javax.jms.*;
@MessageDriven(mappedName = "jms/MyQueue",
    activationConfig = {
        @ActivationConfigProperty(propertyName =
            "acknowledgeMode", propertyValue =
            "Auto-acknowledge"),
        @ActivationConfigProperty(propertyName =
            "destinationType", propertyValue =
            "javax.jms.Queue")
 })
public class SampleMDB implements MessageListener {
 public void onMessage(Message message) {
 // Do something
 }
}
```
## 8. Понятие транзакции. Управление транзакциями в Java EE. JTA.

Транзакция — группа последовательных операций, представляет собой логическую единицу работы с данными. Транзакция либо выполняется успешно и целиком, соблюдая целостность данных, либо не производит никакого эффекта на данные.

Java Transaction API позволяет выполнять распределенные транзакции, т.е. транзакции, читающие и обновляющие данные на разных сетевых ресурсах (которыми могут быть различные серверы баз данных, JMS).

JTA предоставляет высокоуровневый интерфейс для управления транзакциями (begin, commit, rollback), избавляя от необходимости работы с каждым ресурсом по-своему (интерфейс транзакций в JDBC, например, немного отличается от интерфейса JMS).

Транзакция координируется transaction manager'ом. Взаимодействие с ресурсами осуществляется через resource manager'ы.

Транзакции могут быть объявлены:
- декларативно — аннотацией @Transactional на отдельном методе или всем классе, при этом rollback происходит при необработанном RuntimeException
- программно — вызывая begin, rollback, commit у UserTransaction

В дополнение (там немного, но важно): http://tomee.apache.org/jpa-concepts.htm

## 9. Веб-сервисы. Технологии JAX-RS и JAX-WS.

- Позволяют организовать взаимодействие между
сетевыми ресурсами по стандартизированному
протоколу.
- Ресурсы могут работать на любой платформе.
- Данные «упаковываются» в XML и передаются по
HTTP.
- Основные стандарты — SOAP, WSDL и WS-I.
- На платформе Java EE реализуются JAX-WS API и
JAX-RS API.
- Основа SOA (Service Oriented Architecture).

JAX-WS:

```java
package example;
import javax.jws.*;
@WebService
public class SayHello {
 @WebMethod
 public String getGreeting(String name){
 return "Hello " + name;
 }
}
```

Пример JAX-RS (REST веб-сервис)

```java
import javax.enterprise.ApplicationScoped;
import javax.ws.rs.*;

@ApplicationScoped
@Path("/")
public class Rest {
  @GET
  @Path("echo")
  public String echo(@QueryParam("q") String original) {
    return original;
  }
}
```
Difference between JAX-WS и JAX-RS:

JAX-WS - это Java API для веб-служб на основе XML - стандартный способ разработки веб-служб в нотации SOAP (Simple Object Access Protocol).

Вызов веб-служб осуществляется посредством удаленных вызовов процедур. Для обмена информацией между клиентом и веб-сервисом используется протокол SOAP. Обмен сообщениями между клиентом и сервером осуществляется через сообщения SOAP на основе XML .

Клиентам веб-службы JAX-WS необходим файл WSDL для создания исполняемого кода, который клиенты могут использовать для вызова веб-службы.

JAX-RS - Java API для веб-служб RESTful. Веб-службы RESTful представлены как ресурсы и могут быть идентифицированы с помощью унифицированных идентификаторов ресурсов ( URI ). Вызов удаленной процедуры в данном случае представляет собой HTTP- запрос, а необходимые данные передаются в качестве параметров запроса. Веб-службы RESTful - более гибкие, могут использовать несколько разных MIME- типов. Обычно используется для обмена данными XML или обмена данными JSON (JavaScript Object Notation) ...

## 10. Платформа Spring. Сходства и отличия с Java EE.

### Платформа Spring

Что такое Spring?

Несмотря на то, что Spring не обеспечивал какую-либо конкретную модель программирования, он стал широко распространённым в Java-сообществе главным образом как альтернатива и замена модели Enterprise JavaBeans. Spring предоставляет бо́льшую свободу Java-разработчикам в проектировании; кроме того, он предоставляет хорошо документированные и лёгкие в использовании средства решения проблем, возникающих при создании приложений корпоративного масштаба.

Между тем, особенности ядра Spring применимы в любом Java-приложении, и существует множество расширений и усовершенствований для построения веб-приложений на Java Enterprise платформе. По этим причинам Spring приобрёл большую популярность и признаётся разработчиками как стратегически важный фреймворк.

Пожалуй, наиболее трудной частью объяснения технологии Spring является точная классификация того, что она собой представляет. Обычно Spring описывают как облегченную платформу для построения Jаvа-приложений, но с этим утверждением связаны два интересных момента.

Во-первых, Spring можно применять для построения любого приложения на языке Java (например, автономных, веб-приложений или приложений Java Enterprise Edition (JEE)) в отличие от многих других платформ (таких как Apache Struts, которая ограничена созданием только веб-приложений).

Во-вторых, характеристика облегченная в действительности не имеет никакого отношения к количеству классов или размеру дистрибутива, а вместо этого определяет принцип всей философии Spring — минимальное воздействие. Платформа Spring является облегченной в том смысле, что для использования всех преимуществ ядра Spring вы должны вносить минимальные (если вообще какие-либо) изменения в код своего приложения, а если в какой-то момент вы решите прекратить пользоваться Spring, то и это сделать очень просто.

Обратите внимание, что речь идет только о ядре Spring - многие дополнительные компоненты Spring, такие как доступ к данным, требуют более тесной привязки к Spring Framework. Однако польза от такой привязки вполне очевидна.

Spring, вероятно, наиболее известен как источник расширений (features), нужных для эффективной разработки сложных бизнес-приложений вне тяжеловесных программных моделей, которые исторически были доминирующими в промышленности. Ещё одно его достоинство в том, что он ввел ранее неиспользуемые функциональные возможности в сегодняшние господствующие методы разработки, даже вне платформы Java.

Этот фреймворк предлагает последовательную модель и делает её применимой к большинству типов приложений, которые уже созданы на основе платформы Java. Считается, что Spring реализует модель разработки, основанную на лучших стандартах индустрии, и делает её доступной во многих областях Java.

#### Преимущества: 

Spring Framework обеспечивает решения многих задач, с которыми сталкиваются Java-разработчики и организации, которые хотят создать информационную систему, основанную на платформе Java. Из-за широкой функциональности трудно определить наиболее значимые структурные элементы, из которых он состоит. Spring Framework не всецело связан с платформой Java Enterprise, несмотря на его масштабную интеграцию с ней, что является важной причиной его популярности.

- Относительная легкость в изучении и применении фреймворка в разработке и поддержке приложения.
- Внедрение зависимостей (DI) и инверсия управления (IoC) позволяют писать независимые друг от друга компоненты, что дает преимущества в командной разработке, переносимости модулей и т.д..
- Spring IoC контейнер управляет жизненным циклом Spring Bean и настраивается наподобие JNDI  lookup (поиска).
- Проект Spring содержит в себе множество подпроектов, которые затрагивают важные части создания софта, такие как вебсервисы, веб программирование, работа с базами данных, загрузка файлов, обработка ошибок и многое другое. Всё это настраивается в едином формате и упрощает поддержку приложения.

#### Все про Spring:

- https://jsehelper.blogspot.com/2016/02/spring-framework-1.html
- https://jsehelper.blogspot.com/2016/03/spring-framework-2.html
- https://jsehelper.blogspot.com/2016/03/spring-framework-3.html

#### Важные заметки для себя:
- Аспектно-ориентированное программирование (АОП) — это парадигма программирования являющейся дальнейшим развитием процедурного и объектно-ориентированного программирования (ООП). Идея АОП заключается в выделении так называемой сквозной функциональности.
Т.е. есть функциональность которая затрагивает несколько модулей, но она не имеет прямого отношения к бизнес коду, и ее хорошо бы вынести в отдельное место, это и показано на рисунке выше.
- Prototype scope creates a new instance every time getBean method is invoked on the ApplicationContext. Where as for request scope, only one instance is created for an HttpRequest

### Отличие Spring от JavaEE
Проще говоря, Java EE — для легко масштабируемого монолитного приложения, Spring — для совсем маленьких приложений с GUI на Front-end или для микросервисной архитектуры.

https://dou.ua/lenta/articles/javaee-vs-spring/

Конкурентном Java EE считается Spring Framework. Если взглянуть на развитие двух данных платформ, выходит интересная картина. Первые версии Java EE были созданы при участии IBM. Они вышли крутыми, но неповоротливыми, тяжеловесными, неудобными в использовании. Разработчики плевались из-за необходимости поддерживать большое количество конфигурационных файлов и из-за прочих причин, усложняющих разработку.

В то же время на свет появился Spring IoC. Это была маленькая, красивая и приятная в обращении библиотека. В ней также использовался конфигурационный файл, но в отличии от Java EE, он был один. Простота Spring привела к тому, что практически все стали использовать данный фреймворк в своих проектах. 

А далее Spring и Java EE начали свой путь к одному и тому же, но с разных концов. Компания Pivotal Software, разработчик Spring, стали выпускать проект за проектом, чтобы покрыть все возможные и невозможные потребности Java-разработчиков. Постепенно то, что раньше называлось Spring, сначала стало одним из проектов, а потом и вовсе слилось с несколькими другими проектами в Spring Core. Все это привело к неминуемому усложнению Spring по сравнению с тем, каким он был изначально. Со временем следить за всем клубком зависимостей спринга стало уж совсем сложно, и возникла потребность в отдельной библиотеке, которая стала бы загружать и запускать все сама (сейчас где-то икнул так горячо любимый Spring Boot).

Все это время JCP работал над одним — добиться максимального упрощения всего, что только можно внутри Java EE. В итоге в современном EJB для описания бина достаточно указать одну аннотацию над классом, что предоставляет разработчику доступ ко всей мощи технологии Enterprise Java Beans. И подобные упрощения затронули каждую спецификацию внутри Java EE. 

В итоге по функционалу Spring и Java EE примерно разделяют паритет. Где-то что-то лучше, где-то что-то хуже, но если смотреть глобально, больших различий нет. То же самое касается сложности работы. И Spring, и Java EE являются превосходными инструментами. Пожалуй, лучшими из того, что сейчас есть, для построения корпоративных сетевых приложений на языке Java. 

!! Однако, Java EE может работать в общем случае только в рамках Enterprise Application Server’a (Tomcat таковым не является), а приложение на Spring стеке может работать на чем угодно (на том же Tomcat), и даже вообще без сервера (так как запустит его внутри себя самостоятельно).

!! Это делает Spring идеальным инструментом для разработки небольших приложений с GUI на Front-end или для микросервисной архитектуры. Но отказ от зависимости от серверов приложений отрицательно сказался на масштабируемости Spring-приложений.

А Java EE хорошо подходит для реализации масштабируемого монолитного кластерного приложения.

#### Детальное сравнение

1. Spring DI (Dependency Injection) vs CDI (Context Dependency Injection)

   Даже из названия понятно, что ядра в обоих стеках совершенно идентичны по характеристикам. Так и есть. Фактически в Java EE стеке изначально и использовался спринговый DI. Но после того как его включили прямо в Core, использовать его отдельно стало невозможно. Пришлось делать свой DI с аннотациями и программистками.
   
2. Spring Beans vs EJB (Enterprise Java Beans)

   Тут, скажем, ситуация прямо противоположная. Spring beans — это просто обычные джава бины, которые можно куда-то заинжектить и ничего больше. EJB — достаточно мощная штуковина, в которую встроена поддержка распределенного (мультинодного) исполнения, включая распределенный сборщик мусора, аутентификацию, поддержку транзакций и черти что еще. Другой разговор, если все это вам не надо... Ну вы поняли :)
   
3. Spring Service Locator vs JNDI

   Тут тоже ситуация аналогичная. Служба, помогающая найти в том же JVM сервис, и служба, которая может работать на распределенной системе и находить соответствие между чем угодно. Включая привязку к LDAP компании... Формально, предназначены они для одного и того же, однако согласитесь — разница на лицо.
   
4. @Async vs JMS

   Асинхронность также реализована в обоих стеках на разном уровне. В стеке Java EE это отдельная, да, вы правильно догадались, распределенная служба, поддерживающая передачу сообщений не только точка-точка, но и многим получателям. Естественно, отказоустойчивая, персистентная и так далее. В общем, ситуация аналогичная с предыдущими пунктами. Простое и быстрое против распределенной навороченной фиговины.
   
   ![alt text](resources/JMS.png "JMS API")
   
5. Spring MVC vs Java Server Faces (JSF)
    
    Проблема этого сравнения в том, что SpringMVC в качестве темплейтного движка обычно используется Thymeleaf или в более современном варианте — какой-либо Front-end движок (React, Angular & etc). В то время, как JSF — полноценное GUI решение с поддержкой AJAX из коробки и даже SPA приложений с помощью дополнительных библиотек, включая такие гиперудобные и красивые, как PrimeFaces и IceFaces.

    Примерчик из жизни:  
    И тут оказалось, что нативной поддержки AJAX в Spring MVC + Thymeleaf просто нет. Надо каждую операцию писать руками. А у нас практически каждый элемент требует AJAX поведения, причем в разных ситуациях — разного. И писать эту тонну JavaScript мои джаверы вообще не горят желанием. Ну что же. Скрепя сердце были вынуждены выкинуть весь написанный интерфейс и переделать все приложение на Angular (для чего взять еще и Front-end разработчика). И заняло это переписывание где-то больше месяца. Вот и считайте, в какие деньги вышло заказчику наше решение использовать стек Spring.
    
6. Spring Data vs JPA  

   Это единственный пункт, в котором Spring кроет как бык овцу стек Java EE. Spring Data — прекрасна, великолепна, быстра и удобна. Снимаю шляпу. Очень жаль, что аналога в Java EE стеке нет...
   
7. Spring Security vs JAAS

   Что хотел я сказать... Spring Security — фреймворк, который мне создал на моих проектах проблем больше, чем все остальные вместе взятые. Возможно, документация фиговая (это единственный Spring фреймворк с фиговой документацией). Возможно, сама тема сложная, но мои программисты традиционно мучаются с ней очень много. Полномасштабного использования JAAS у нас пока не было, но то, что простейшее — прилепляется легко.
   
   Отличия фреймворков вы понимаете и сами. JAAS, естественно, поддерживает распределенность.
   
8. Spring Boot vs Enterprise Server

   Все фанаты спрингового стека любят превозносить Spring Boot со словами «он прекрасен, с ним так все легко», забывая, что этот фреймворк — настоящие костыли, без которых связать воедино весь тот ад, который нафигачили ребята из проекта Spring просто очень сложно.
   
   Напоминаю, что аналогом Spring Boot для стека Java EE является просто любой Enterprise server. Там уже есть все нужные фреймворки нужных и консистентных версий, уже настроенные для работы друг с другом.
   

#### Java EE:

1. Java EE промышленности утверждены типовые основы API
2. Он преимущественно основан на аннотациях и CDI
3. JFC MVC framework для веб-разработки
4. JPA спецификация для обработки операции DB
5. JTA API с внедрением
6. EJB контейнерная и POJO основанная реализация
7. Oracle лицензия

#### Spring:

1. На основе IOC и AOP
2. На основе конфигурации XML (теперь они используют аннотацию)
3. Использует фреймворк Spring DAO (основанный на шаблоне дизайна шаблона) для подключения к базе данных
4. Предоставляет уровень абстракции для поддержки различных реализаций JTA.
5. Интегрируется с различными поставщиками Java для поддержки различных возможностей, таких как struts и т. д
6. Обеспечивает платформу end-to-end для построения веб-приложения, достигая свободной связи с использованием DI и AOP
7. Лицензия с открытым исходным кодом

## 11. Модули Spring. Архитектура Spring Runtime. Spring Security и Spring Data.

Spring потенциально может быть универсальным магазином для всех ваших корпоративных приложений. Однако Spring является модульным, позволяя вам выбирать, какие модули вам подходят, без необходимости вносить остальные. В следующем разделе приведены сведения обо всех модулях, доступных в Spring Framework.

#### Основной контейнер

Базовый контейнер состоит из модулей Core, Beans, Context и Expression Language, подробности которых следующие:

- Модуль Core обеспечивает основные части платформы, включая функции IoC и Dependency Injection.
- Модуль Bean предоставляет BeanFactory, которая представляет собой сложную реализацию фабричного шаблона.
- Модуль Context основан на прочной основе, предоставляемой модулями Core и Beans, и является средой для доступа к любым объектам, определенным и настроенным. Интерфейс ApplicationContext является координационным центром модуля Context.
- Модуль SpEL предоставляет мощный язык выражений для запросов и манипулирования графом объектов во время выполнения.

Уровень доступа к данным / интеграции состоит из модулей JDBC, ORM, OXM, JMS и Transaction, подробности которых следующие:

- Модуль JDBC предоставляет уровень абстракции JDBC, который устраняет необходимость в утомительном кодировании, связанном с JDBC.
- Модуль ORM предоставляет слои интеграции для популярных API объектно-реляционного отображения, включая JPA, JDO, Hibernate и iBatis.
- Модуль OXM предоставляет уровень абстракции, который поддерживает реализации отображения объектов / XML для JAXB, Castor, XMLBeans, JiBX и XStream.
- Модуль JMS Java Messaging Service содержит функции для создания и потребления сообщений.
- Модуль Transaction поддерживает программное и декларативное управление транзакциями для классов, которые реализуют специальные интерфейсы, и для всех ваших POJO.

Веб-слой состоит из модулей Web, Web-MVC, Web-Socket и Web-Portlet, подробности которых приведены ниже:

- Веб- модуль обеспечивает базовые функции веб-интеграции, такие как функция многоэтапной загрузки файлов и инициализация контейнера IoC с использованием прослушивателей сервлетов и контекста веб-ориентированного приложения.
- Модуль Web-MVC содержит реализацию Spring-Model-View-Controller (MVC) для веб-приложений.
- Модуль Web-Socket обеспечивает поддержку двусторонней связи на основе WebSocket между клиентом и сервером в веб-приложениях.
- Модуль Web- портлета предоставляет реализацию MVC для использования в среде портлета и отражает функциональность модуля Web-Servlet.

## 12. Реализация IoC и CDI в Spring. Сходства и отличия с Java EE.

### Описание работы IoC контейнера

Ниже представлена диаграмма, отражающая, как работает Spring. Ваши классы приложения совмещаются с метаданными конфигурации, в результате чего будет создан и инициализирован ApplicationContext, а на выходе вы получите полностью настроенное и готовое к выполнению приложение.

![alt text](resources/IoC_Spring.png "IoC in Spring")

ApplicationContext представляет собой Spring IoC контейнер и необходим для инициализации, настройки и сборки бинов для построения приложения.

В метаданных конфигурации разработчик описывает как инициализировать, настроить IoC контейнер и собрать объекты в вашем приложении. В данном и других уроках этого цикла везде, где возможно, будет использоваться подход на основе аннотаций и Java-конфигурации. Если вы сторонник XML-конфигурации, либо хотите посмотреть как делать тоже самое через XML, обратитесь к оригинальной документации по Spring Framework или соответствующего модуля/проекта.

Основными признаками и частями Java-конфигурации IoC контейнера являются классы с аннотацией @Configuration и методы с аннотацией @Bean. Аннотация @Bean используется для указания того, что метод создает, настраивает и инициализирует новый объект, управляемый Spring IoC контейнером. Такие методы можно использовать как в классах с аннотацией @Configuration, так и в классах с аннотацией @Component(или её наследниках). Класс с аннотацией @Configuration говорит о том, что он является источником определения бинов. Самая простейшая из возможных конфигураций выглядит следующим образом:

```java
package lessons;

import org.springframework.context.annotation.Configuration;

/**
 * Конфигурационный класс Spring IoC контейнера
 */
@Configuration
public class LessonsConfiguration {
}
```
Для того, чтобы приступить к настройке и изучению Spring IoC контейнера, вы должны инициализировать ApplicationContext, который поможет также с разрешением зависимостей. Для обычной Java-конфигурации применяется AnnotationConfigApplicationContext, в качестве аргумента к которому передается класс, либо список классов с аннотацией @Configuration, либо с любой другой аннотацией JSR-330, в том числе и @Component

```java
public class Starter {

    private static final Logger logger = LogManager.getLogger(Starter.class);

    public static void main(String[] args) {
        logger.info("Starting configuration...");

        ApplicationContext context = new AnnotationConfigApplicationContext(LessonsConfiguration.class);
    }
}
```
```java
package lessons.services;

public interface GreetingService {
    String sayGreeting();
}
```
```java
package lessons.services;

public class GreetingServiceImpl implements GreetingService {

    @Override
    public String sayGreeting() {
        return "Greeting, user!";
    }
}
```

```java
@Configuration
public class LessonsConfiguration {
    @Bean
    GreetingService greetingService() {
        return new GreetingServiceImpl();
    }
}
```

```java
public class Starter {

    private static final Logger logger = LogManager.getLogger(Starter.class);

    public static void main(String[] args) {
        logger.info("Starting configuration...");

        ApplicationContext context = new AnnotationConfigApplicationContext(LessonsConfiguration.class);
        GreetingService greetingService = context.getBean(GreetingService.class);
        logger.info(greetingService.sayGreeting());  // "Greeting, user!"
    }
}
```

Полезная ссылка: https://spring-projects.ru/guides/lessons/lesson-2/

### Сходства и отличия с Java EE

Короче, пишу, как думаю я. 

Есть IoC - инверсия контроля (я завишу от кого-то, но не я буду его дергать (хотя это нужно мне), а кто-то "сверху" (контейнер (контекст)) будет поставлять мне то, от чего я хочу зависеть, таким образом достигается меньшая связанность, а => гибкость ).  
 
Ну и IoC это просто концепция (подход), а вот DI (в Spring) и CDI (в Java EE) - это реализации этого подхода. Да и прикол в том, что почти идентичные (по сути делают они одно и то же, но названия аннотаций разные)   
Напоминание: Фактически в Java EE стеке изначально и использовался спринговый DI. Но после того как его включили прямо в Core, использовать его отдельно стало невозможно. Пришлось делать свой DI с аннотациями и программистками.

Но почему в Spring DI, а в Java EE CDI? Я могу предположить, что сязано это с тем, что для Java EE обязательно нужен Enterprise Application Server’a (Tomcat таким не является), поэтому Context всегда уже реализован в нем и содержится в этом сервере.

А что касается Spring, там используется DI, так как Context всегда реализуется самим програмистом (ApplicationContext)

Но, само собой, я могу ошибаться.


## 13. Реализация REST API в Java EE и Spring.



## 14. React JS. Архитектура и основные принципы разработки приложений.

### React JS
Начнем с того, что React - это JS библиотека(!!!). Обратите внимание, что именно
библиотека, а не фреймворк (отличаются инверсией управления), которая
предназначена для создания пользовательских интерфейсов. 

У него открытый исходный код. Если говорить о популярности, то у
реакта 160 тысяч звездочек. К примеру, у Ангуляра 68 тысяч.

На слайде есть картиночка вольного сравнения популярности Vue, Angular и
React с помощью гугл трендов. Реакт достаточно популярен сейчас, но это не в
коем случае не значит, что нужно использовать только реакт. Например, Angular
имеет более mvc - шную архитектуру, а у Vue гораздо субъективно меньше порог
вхождения.

Также React предназначен в основном для создания одностраничных
приложений или Single Page Application.

### SPA

#### SPA — подход, в котором:

- Используется один html-документ
- Динамическое обновление благодаря JavaScript
- Быстрый отклик
- Простота разработки
- Возможность работы в offline режиме

Что это вообще такое? Это такой подход к созданию веб-приложения, при
котором используется только один html-документ. Все нужные ресурсы
загружаются при первом запросе. Далее все взаимодействие осуществляется с
помощью javascript подгрузки необходимых частей данных.  
Ощутимое преимущество данного подхода - это достаточно высокая скорость
работы веб-приложения, что очень напоминает десктопное приложение так как
нет перезагрузок и подгрузки новых страниц. Благодаря этому можно создать
пользовательский интерфейс достаточно сложным, затратив минимальное
количество усилий.  
Также важной особенностью является возможность продолжения работы в offline
режиме благодаря кэшированию данных. Яркий пример, почему это хорошо -
допустим, листаете вы ленту в инстаграмме в метро и тут у вас пропадает
интернет, было бы круто, если при этом часть данных подгрузилась и вы смогли
бы еще какое-то время листать эту ленту

#### Минусы

- Долгая первая загрузка
- Нет поддержки javascript == нет приложения
- SEO
- Большая часть взаимодействия на клиенте

Но при этом у данного подхода есть определенные недостатки.
Самый очевидный из них - если в браузере отключена поддержка javascript, то
тут ничего не сделать кроме как просить пользователя включить его.  
Ну и конечно, первая загрузка у вас будет несколько дольше. Может вы
замечали когда-нибудь, что сайт сначала грузится очень долго, а потом
переходы на его другие страницы происходят достаточно быстро. Есть
вероятность, что скорее всего вы столкнулись с SPA приложением, которое
вначале просто загрузил все ему нужные скрипты, а дальше только
подхватывал нужные ему данные и встраивал в страницу.  
Также у SPA есть определенные проблемы с SEO в ввиду наличия только одной
html страницы.  
Так как большая часть взаимодействия с пользователем
переложена на SPA, то это влечет за собой некоторые проблемы с
безопасностью.

### Основные принципы разработки веб-приложения

![alt text](resources/reactComponents.png)

Начнем с того, что реакт основан на компонентах. Все ваше приложение
разделено на компоненты. Компонент - это некоторый инкапсулированный
элемент. На слайде есть пример интерфейса, разбитого на компоненты. Каждый
компонент предназначен для определенной цели. Например, отобразить имя,
аватарку и статус работника.  
И главное удобство заключается в том, что
компоненты можно переиспользовать - для того, чтобы показать список
работников, нам нужно взять шесть EmployeeListItem, а точнее использовать
один компонент и тот же компонент шесть раз, которому нужно сказать, какие
имя, статус и аватарку ему показывать. Это удобно, когда у вас в интерфейсе
много одинаковых элементов, которые вы не пишите каждый раз с нуля.  
Также здесь можно заметить свое дерево компонентов. В компоненте App
находятся HomePage и EmployeePage, дальше в HomePage лежит Header,
SearchBar и тд.

Это первая важная особенность React

### Архитектура приложения

#### VDOM

![alt text](resources/VDOM.png)

Cледующая - это Virtual DOM. DOM -
объектная модель документа. У реакта достаточно интересное взаимодействие
с DOM.  
Каждое изменение DOM - достаточно дорогостоящая операция. Поэтому
в реакте есть такая концепция как Virtual DOM. По сути изначально это полная
копия DOM. Однако, если вы взаимодействуете с каким-нибудь элементом,
реакт изменяет не реальный DOM, а только виртуальный. Далее он сравнивает
виртуальный дом с реальным - этот процесс называется сверкой или патчем и
происходит с помощью библиотеки ReactDOM - и если они различаются, то
реакт изменяет только ту часть DOMа, где он различается с виртуальным. в
каком-то смысле виртуальный дом - некоторая прослойка между вашим
приложением и DOM.

#### Как строит дерево React

![alt text](resources/reactTree.png)

Есть два типа элементов - ReactComponentElement и ReactDOMElement.
- ReactComponentElement - ссылка на соответствующую функцию(класс) этого
компонента.
- ReactDOMElement - виртуальное представление DOM-элементов.


## 15. Компоненты React. State & props. "Умные" и "глупые" компоненты.

### Компоненты React 

Проще всего описывать компонент как функцию - пример функции. Однако
можно использовать и классы, но это достаточно устаревший подход. С точки
зрения React - оба подхода эквивалентны.

Чтобы отрендерить элемент используем функцию ReactDom.render(element,
document.getElementById(‘root’);
Clean Code:
Название компонента - всегда с большой буквы

```javascript
ReactDOM.render(
            <App/>,
    document.getElementById('root')
)
```

#### Жизненный цикл 

1. инициализация — создание экземпляра класса компонента
2. монтирование — компонент вставляется в DOM
3. обновление — компонент обновляется новыми данными через состояние или свойства
4. размонтирование — компонент удаляется из DOM

У всех компонентов в реакте есть жизненный цикл. Его важно понять и
осмыслить - это одно из основополагающих знаний хорошего реакт
разработчика. На начальном этапе, конечно, вам не нужно помнить абсолютно
все этапе, но основные - точно. Давайте их рассмотрим.

![alt text](resources/lifecycleComponent.png)

Updation:

shouldComponentUpdate - говорим, следует отрисовывать заново элемент или нет

props - componentWillReceiveProps - перед тем, как обновялются props, предыдущее состояние props'ов можно сохранить с помощью этой функции

Unmouting:

componentWillUnmount - что-то хотим сделать перед размонтированием (pop up открылся и нужно закрыть pop up и закрыть красиво и накинуть анимацию) 

### Props

```javascript
const EmployeeListItem = (props) =>
    <div>
        {props.name} - {props.status}
    </div>
);
```
```javascript
<EmployeeListItem name=”James King” status=”President and CEO”/>
```

Теперь нам нужно передать трем элементам разные фамилии и статус. Сделать мы это
можем через пропсы. Пропсы - это входные данные, которые мы передаем
функции - пример.  
Очень важное замечание - пропсы можно только читать. Другими словами, все
реакт компоненты должны вести себя как чистые функции. Это правило ни в
коем случае нельзя нарушать при написании React приложения.

### State

```javascript
const EmployeeListItem = (props) =>
    const [age, setAge] = useState(1) //Задается начальное состояние
        <div>
            {props.name} - {props.status}
            <br/>
            {age} //Будет выведено: 1
        </div>
);
```

Компонент может хранить в себе свое состояние и изменять его. В
функциональных компонентах для объявления переменной состояния
используется хук useState. Хук - это специальная функция, расширяющая
возможности функциональных компонентов. Хуки можно использовать только
внутри функциональных компонентов.  
Состояние компонента меняется только через предоставленную функцию, так
как реакт может сам заменить значение переменной, если вы изменяете ее
напрямую, а также он не будет в курсе сделанному вами изменению.   
Также в реакте данные передаются только в одном направлении - вы не
сможете обратиться к переменной родителя из ребенка. Единственный способ -
это сделать - передать в пропсы специальную функцию от родителя,
предоставляющую доступ к переменной.

### Events

```java
const EmployeeListItem = (props) =>
    const clickHandler = (e) => {console.log(e)}
    const [age, setAge] = useState(1) //Задается начальное состояние
        <div>
            <button onClick={clickHandler}>Click!</button>
            <br/>
            {age} //Будет выведено: 1
        </div>
     );
```

Работа с событиями - пример. e - синтетическое событие. Не нужно добавлять
addEventListener (привет jquery)

### Циклы

```javascript
const List = () =>
    <div>
        {[1,2,3].map((el,index)=><span key={index}>{el}</span>)}
    </div>
```

Работа с циклами в реакте аналогично обычному javascript - пример рендера
несколько элементов.

## 16. Разметка страниц в React-приложениях. JSX.

### React.createElement(...)

![alt text](resources/reactCreateElement.png)

У реакта одна из главных функций - React.createElement(component, props,
children). С помощью нее можно создать элемент. Давайте посмотрим на
практике, как она работает:

На основе данной структуры реакт рекурсивно обходит дерево компонентов и
строит VDOM.

Естественно, описывать каждый элемент подобным способом - особый вид
извращения, это выглядит явно сложно читаемым, поэтому был придуман
синтаксический сахар - JSX.

### JSX

![alt text](resources/JSX.png)

JSX - расширение Javascript, которое позволяет писать код, похожий на HTML.
Препроцессор JSX (К примеру, Babel), анализирует весь ваш код и преобразует
его в обычный javascript.


## 17. Навигация в React-приложениях. ReactRouter.

### React-router

React-router специально вынесен в отдельную библиотеку, потому что у нее есть опред свой функционал

Она позволяет реализовывать навигацию между компонентами  

![alt text](resources/react-router.png)

history - объект, сохраняющий историю и позволяющий вручную переходить на какие-нибудь компоненты


## 18. Управление состоянием интерфейса. Redux.

Redux - менеджер состояния. Чаще всего используется с React, но не
привязан к нему. 

![alt text](resources/redux.png)

Redux - хранилище для всего нашего приложения и мы можем из любого компонента получить состояние переменной, который находится в общем хранилище и подписаться на ее изменение, либо кинуть экшен на ее изменение

### Важная особенность Redux:

Данные напрямую в store обновить НЕЛЬЗЯ  
Чтобы оновить данные, мы отправляем action  
Который кидает запрос на обработку какого типа был action  
И только потом изменяется значение в store 

### Особенности

- Общее, одно состояние данных, доступное из любого компонента
- Состояние изменяется только с помощью action, но не напрямую
- В компоненте можно подписаться на изменения определенного
значения
- Компоненты могут иметь свое состояние(state), но только если оно
важно только для данного компонента


… кода становится в несколько раз больше :(

### Store

Похож на state компонента, только он глобальный

Объект, который содержит состояние приложения и является
уникальным.

Является неизменяемым - обновляется путем создания нового объекта. (удаляем прошлое значение)

const store = createStore( initialState, reducer)

- getState()
- dispatch(action) - генерация события
- subscribe(listener) - подписка на изменения
- replaceReducer(nextReducer)

### Reducer

Чистая функция, которая вычисляет новое состояние.

Мы отправляем ей действие, проверяется тип действия

```javascript
function counterReducer(state = initialState, action) {
    if (action.type === 'counter/increment') {
        return {
            ...state,
            value: state.value + 1
        }
    }    
   
    return state
}
```

Возвращаем дефолтное состояние стейта, так как он проходит еще одну итерацию

### Action

Некоторое событие, которое должно привести к изменению состоянию.

С точки зрения js - это любой объект, имеющий идентификатор события
(type)

Action передается в reducer


```javascript
const addToDo = (name) => ({
    type: ‘ADD_TO_DO’,
    payload: { name }
})

```
### Dispatch

Функция redux, которая генерирует события.

dispatch(addToDo);

### Redux схема

![alt text](resources/reduxScheme.png)

### Middleware

Усилители. Главная их суть - принять входные данные действия, обработать и отправить дальше. Часто используются для работы с api

Например, мы хотим, чтобы при клике на кнопку отправился запрос на сервер, после запроса на сервер в зависимости от ответа мы обновили состояние store.
Тут и используется middleware. Мы синхронно отправляем запрос, ожидаем ответа, в зависимости от ответа (состояния промиса) она вызывает опрделенный action 

![alt text](resources/middleware.png)

## 19. Angular: архитектура и основные принципы разработки приложений.

Angular - в отличие от react это фреймворк

В общем случае написан на TypeScript. За 4 года 9 релизов.

Angular - развитие библиотеки AngularJS. Т. е в 2016 году Angular=fork AngularJS. Дальше они развивались независимо

### Особенности Angular

Так как Angular -  это фреймворк, поэтому, чтобы начать разрабатывать приложение на нем, нужно сделать некую предварительную работу. Какую?

- Для разработки нужно настроить соборочное окружение (на базе node.js и npm). Ну и в этом окружении клиентскую часть нашего приложения собирать 
- Приложения состоят из модулей ( наследники класса NgModules) 
- Модули обеспечивают контекст для компонентов (components)
- Из компонентов строятся представления (views)
- Компоненты взаимодействуют с сервисами (элементы, реализующие логическую составляющую нашего фронта) (services) с помощью DI

### Архитектура приложения на базе Angular

![alt text](resources/architectureAngular.png )

- Шаблон и комонент циклически обмениваются (путем биндинга пропертей и событий)
- В компонент встраиваются сервисы путем использования Injector'a (он отвечает за DI в Angular)
- Template (шаблон) использует метаданные заданной директивы, связывая себя с пропертями.

## 20. Angular: модули, компоненты, сервисы и DI.

### Модули

- Не совсем то же самое, что модули в ES6 (хотя и похожи)
- Каждый модуль обеспечивает контекст компиляции для одного или группы компонентов
- Модули могут связывать компоненты с сервисами, необходимыми для работы этих компонентов
- Группировка компонентов по модулям - на усмотрение программиста 
- Каждое приложение обязательно включает в себя корневой модуль (root module) под названием AppModule (файл app.module.ts)
- Модули могут ссылаться друг на друга (возможны импорт и экспорт модулей)
- Могут быть использованы для реализации ленивой загрузки (загрузка по требованию) lazy loading

#### Структура модуля

- Каждый модуль - класс TS с декоратором @NgModule() (декоратор - подобие аннотации)
- Содержит секции
    - declarations - компоненты, директивы, фильтры, содержащиеся в этом модуле
    - exports - то, что объявлено в этой секции, будет видно и доступно для использования в других модулях
    - imports - список внешних модулей, содержимое секции exports которых используется в текущем модуле
    - providers - сервисы, реализованные в этом модуле, видимые в глобальном контексте приложения
    - bootstrap - главное предсталвение приложения (объявляется только в корневом модуле). С него начинается рендеринг интерфейса приложения
    
#### Пример модуля

![alt text](resources/moduleExampleAngular.png)


### Компоненты 

- У всех компонентов внутри одного модуля общий _контекст компиляции_. При компиляции они друг друга видят и компилятор видит все компоненты этого модуля
- Каждый компонент - отдельный класс
- Контролирует область экрана, называемую представлением (div-чик или блок)
- Ангуляр управляет жизненным циклом компонентов


 ![alt text](resources/componentAngular.png)

### Представления (views)

- Компоненты и их шаблоны (templates) формируют представления (views)
- Комонент может содержать иерархию представлений (view hierarchy)
- Каждый компонент содержит корневое представление, с которого начинается рендеринг интерфейса (host view)
 
### Метаданные компонента

- Задаются с помощью декоратора @Component
- Сообщает рантайму о том, что это за компонент и где искать его составляющие

 ![alt text](resources/metadataOfComponentAngular.png)

### Фильтры

 ![alt text](resources/pipes.png)

### Директивы

 ![alt text](resources/directives.png)

### Сервисы и DI

- Сервисы (services) реализуют какие-либо действия, не формируя представление (логика средствами сервиса не отражается на интерфейс, потом она как-то в интерфейсе может отразиться, но не прямым путем)
- Реализуются в виде отдельых классов в соответствии с принципами ООП
- Компонент может делигировать какие-либо из своих задач сервисам 
- Доступ компонентов к сервисам реализуется с помощью DI

 ![alt text](resources/servicesExample.png)

### DI - осуществляется элементом Angular Injector' ом

- Компоненты могут использовать сервисы с помощью DI
- Для того, чтобы класс можно было использовать с помощью DI, он должен содержать декоратор @Injectable()

#### Основные принципы реализации DI

- Приложение содержит как минимум один глобальный Injector, который занимается DI (Injector'ов может быть >1)
- Injector создает зависимости и передает их экземпляры контейнеру (container)
- Провайдер (provider) - это объект, который сообщает Injector'у, как получить или создать экземпляр зависимости
- Обычно провайдером сервиса является сам его класс 
- Зависимости компонентов указываются в качестве параметров их конструкторов 

#### Провайдеры для сервисов

 ![alt text](resources/providers.png)



## 21. Angular: шаблоны страниц, жизненный цикл компонентов, подключение CSS.

### Шаблоны и представления

- Представление (view) компонента задается с помощью шаблона (template) - та самая разметка, которая будет сформирована при просмотре компонента (в браузере)
- Представления часто группируются иерархически (складываются друг в друга)
- Компонент может содержать иерархию представлений (view hierarchy), которая содержит встроенные представление (embedded views) из других компонентов

#### Синтаксис шаблонов

- Похож на обычный HTML 
- Взаимодействие с классом компонента осуществляется с помощью ссылок на его свойства (data binding) {{hero.name}}
- Также можно использовать фильтры (pipes) и директивы (directives) 

 ![alt text](resources/syntaxOfTemplate.png)

#### Связь

Связь между шаблоном и компонетом работает в обе стороны:
- Шаблон(реализация компонента) отображает данные с компонента через property binding ({{hero.name}})
- Компонент принимает данные шаблона через event binding ((click) = "selectHero(hero)")

#### Три вида связи

 ![alt text](resources/3typesOfBinding.png)




## 22. Angular: клиент-серверное взаимодействие, создание, отправка и валидация данных форм.

### Взаимодействие с back-end'ом

 ![alt text](resources/interactionWithBackend.png)

### Использование HttpClient

 ![alt text](resources/UsageHttpClient.png)

### Пример получения JSON с сервера 

 ![alt text](resources/GettingJsonFromServer.png)

 ![alt text](resources/GettingJsonFromServer2.png)


## Концепция Single Page Application

### SPA

Одностраничное приложение — это веб-приложение или веб-сайт, использующий единственный HTML-документ как оболочку для всех веб-страниц и организующий взаимодействие с пользователем через динамически подгружаемые HTML, CSS, JavaScript, обычно посредством AJAX

Single Page Application – сокращенно SPA, в переводе на русский язык означает “Приложение одной страницы”. Другими словами SPA – это web-приложение, размещенное на одной web-странице, которая для обеспечения работы загружает весь необходимый код вместе с загрузкой самой страницы. Приложение такого типа появились сравнительно недавно, с началом эры HTML5 и SPA является типичным представителем приложений на HTML5.

Получается немного скомкано: “Одна страница.. другая станица, третья страница… одностраничный портал”. Расставим все точки над “Ё”. Страница сайта, на котором размещены все ссылки на все CSS, и ссылки на скрипты, необходимые для работы SPA мы назовем “Web-страница”. Файл с такой странице обычно называется “index.html” (в ASP.NET MVC может быть index.cshtml или index.vbhtml или даже index.aspx) А страницы, которые переключает пользователь внутри одностраничного портала назовем “модули”.

#### Плюсы

1) Приложения на SPA отлично работают на устройствах как стационарных, так и мобильных. “Большие” компьютеры, планшеты, смартфоны, и, в конце-концов, простые телефоны (некоторые) могут беспрепятственно работать с сайтами построенных по принципу SPA. Итак, первый “плюс” – работа на большом количестве устройств, а значит, создав одно приложение, вы получаете гораздо большую аудиторию пользователей нежели при использовании стандартного подхода.
(Создать мобильное приложение проще, потому что разработчик может повторно использовать один и тот же внутренний код для веб-приложения и собственного мобильного приложения.)

2) Богатый пользовательский интерфейс, так называемый User Experience. Так как web-страница одна, построить богатый, насыщенный пользовательский интерфейс гораздо проще. Проще хранить информацию о сеансе, управлять состояниями представлений (views) и управлять анимацией (в некоторых случаях).

3) SPA существенно (в разы) сокращает так называемые “хождения по кругу”, то есть загрузку одного и того же контента снова и снова. Если ваш портал (сайт) использует шаблон, то вместе с основным содержанием какой-либо страницы посетитель сайта обязательно загружает разметку шаблона. Да, кэширование данных на данном этапе развития WWW достигло высочайших результатов, но если нечего кэшировать, то и время, и ресурсы на это не тратятся.

4) SPA работает быстро, поскольку большинство ресурсов (HTML + CSS + Scripts) загружаются только один раз за время существования приложения. Только данные передаются туда и обратно.

5) Кэширование данных — приложение отправляет всего один запрос, собирает данные, а после этого может функционировать в offline-режиме.

#### Минусы

1) Плохая SEO оптимизация. SPA работает на основе javascript и загружает информацию по запросу со стороны клиента. Поисковые системы с трудом могут имитировать данное поведение. Потому большинство страниц попросту недоступны для сканирования поисковыми ботами, поэтому продвижение сайта в 2020 может быть усложнено.

2) Неактивный javascript. Некоторые пользователи отключают javascript в своих браузерах, а без него ваше приложение не будет работать.

3) Низкий уровень безопасности. (По сравнению с «традиционным» приложением, SPA менее безопасен. Благодаря межсайтовому скриптингу (XSS) злоумышленники могут внедрять клиентские скрипты в веб-приложение другими пользователями.)

Принципы любого фреймворка (о них поговорим позже), который реализует парадигму SPA должны придерживаться следующих понятий и определений:

- SPA поддерживает клиентскую навигации. Все “хождения” пользователя по модулям-страницам однозначно фиксируются в истории навигации, причем навигация при этом является “глубокой”, то есть если пользователь скопирует и откроет ссылку на внутреннюю модуль-страницу в другом браузере или окне, он попадет на соответствующую страницу.
- SPA размещается на одной web-странице, значит всё необходимое для работы сайта (портала) скрипты и стили должны быть определены в одном месте проекта – на единственной web-странице.
- SPA хранит постоянно состояние (важные переменные) работы клиента (клиентского скрипта) в кэше браузера или в Web Storage.
- SPA загружает все скрипты требующиеся для старта приложения при инициализации web-страницы.
- SPA постепенно подгружает модули по требованию.

### MPA

Многостраничные приложения имеют более классическую архитектуру. Каждая страница отправляет запрос на сервер и полностью обновляет все данные. Даже если эти данные небольшие. Таким образом тратится производительность на отображение одних и тех же элементов. Соответственно это влияет на скорость и производительность.

#### Плюсы 

1) Легкая SEO оптимизация. Архитектура MPA позволяет достаточно легко оптимизировать каждую страницу под поисковые системы.

2) Легкая разработка. Как правило для разработки многостраничного приложения требуется меньший стек технологий.

3) Это идеальный подход для пользователей, которым нужна наглядная карта того, куда идти в приложении. Прочная, многоуровневая навигация по меню - неотъемлемая часть традиционного многостраничного приложения.

4) Множество решений.

#### Минусы

1) Для разработки мобильных приложений потребуется намного больше времени. В большинстве случаев потребуется написание back-end с нуля.

2) Сложно разделить front-end и back-end. Как правило они очень тесно взаимодействуют друг с другом. Усложняется работа front-end и back-end разработчиков.

3) Развитие становится довольно сложным. Разработчик должен использовать фреймворки как на стороне клиента, так и на стороне сервера. Это приводит к увеличению времени разработки приложения.

### Наглядные примеры 

__MPA__. Возьмём среднестатистический сайт, например, воображаемый интернет-магазин плюшевых игрушек MimimiShop. Вы заходите на главную страницу mimimi-shop.ru и видите много-много карточек с мягкими мишками. Чтобы вы смогли их увидеть, браузер послал запрос на сервер и получил файл index.php.

Один мишка очень вам нравится, и вы по нему кликаете. Ссылка меняется на mimimi-shop.ru/teddy-bears/92, страница перезагружается, браузер получает другой файл – product.php. Здесь совершенно другая информация – мишка только один, зато подробно описан.

В классическом Multi Page Application каждый url – это отдельный запрос к серверу с получением нового шаблона.

__SPA__. Перепишем MimimiShop как SPA. Вы заходите на главную страницу mimimi-shop.ru, и браузер загружает всего один файл index.html и большой скрипт mimimi.spa.js. После загрузки скрипт выводит на страницу компонент каталога – множество карточек с мягкими игрушками. Когда вы кликаете на понравившегося мишку, компонент каталога реактивно заменяется на компонент одного товара. Страница при этом не перезагружается, всё происходит красиво и плавно.

В итоге браузер отдал только одну страницу – index.html.

Требования к маршрутизации SPA:

- Переход между страницами должен происходить без перезагрузки.
- Каждый переход должен сохраняться в истории браузера (кнопки Назад/Вперед должны функционировать).
- При вводе в адресную строку некоторого маршрута должен выводиться тот контент, который этому маршруту соответствует, как в мультистраничном приложении.

### Выводы 

Каждая архитектура имеет свои преимущества и недостатки и хорошо подходит для определенного типа проекта. SPA отличается своей скорость и возможностью на базе готового кода разработать мобильное приложение. Но в тоже время, SPA имеет плохую SEO оптимизацию. Таким образом данная архитектура отлично подход для SaaS платформ, социальных сетей, закрытых сообществ, где поисковая оптимизация не имеет значения.

MPA больше подходит для создания крупных интернет магазинов, бизнес сайтов, каталогов, маркетплейсов и т.п. Хорошо оптимизированная MPA имеет высокую скорость и производительность, но все же не позволяет легко разработать мобильное приложение. MPA и SPA с правильной архитектурой хорошо подходят для разработки масштабируемых веб приложений.


## Вопросы к себе

1) Зачем export default в файлах js
2) Отличие react-router от react-router-dom
3) When using Webpack you need to require images in order for Webpack to process them, which would explain why external images load while internal do not, so instead of <img src={"/images/resto.png"} /> you need to use <img src={require('/images/image-name.png')} /> replacing image-name.png with the correct image name for each of them. That way Webpack is able to process and replace the source img.
4) rest easy что це такое
5) Лучше деплоить вместе или раздельно 
6) Отличие Spring от JavaEE тщательнее
7) Как связаны JNDI c IoC, CDI, Location Transparency 
8) Middleware who is it (thunk)
9) 12 вопрос
10) принцип работы redux (dispatch, reducer, store, actions)

Концепция Single Page Application

- конспект видео про Spring (2 часа)
- конспект семинара с Цопой 
- 12 вопрос

# Spring Data (пахнет плохо)

Spring Data — дополнительный удобный механизм для взаимодействия с сущностями базы данных, организации их в репозитории, извлечение данных, изменение, в каких то случаях для этого будет достаточно объявить интерфейс и метод в нем, без имплементации.

Миссия Spring Data состоит в том, чтобы предоставить знакомую и последовательную модель программирования на основе Spring для доступа к данным, сохраняя при этом особые черты базового хранилища данных.

Он упрощает использование технологий доступа к данным, реляционных и нереляционных баз данных, фреймворков с сокращением карт и облачных служб данных. Это зонтичный проект, который содержит множество подпроектов, специфичных для данной базы данных. Проекты разрабатываются в сотрудничестве со многими компаниями и разработчиками, стоящими за этими захватывающими технологиями.

Что умеет: https://habr.com/ru/post/435114/#:~:text=Spring%20Data%20%E2%80%94%20%D0%B4%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9%20%D1%83%D0%B4%D0%BE%D0%B1%D0%BD%D1%8B%D0%B9%20%D0%BC%D0%B5%D1%85%D0%B0%D0%BD%D0%B8%D0%B7%D0%BC,%D0%9C%D0%B5%D1%82%D0%BE%D0%B4%D1%8B%20%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D0%BE%D0%B2%20%D0%B8%D0%B7%20%D0%B8%D0%BC%D0%B5%D0%BD%D0%B8%20%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%B0

data access object (DAO) — абстрактный интерфейс к какому-либо типу базы данных или механизму хранения. Определённые возможности предоставляются независимо от того, какой механизм хранения используется и без необходимости специальным образом соответствовать этому механизму хранения.

В стеке Spring существует проект Spring Data, реализующий большую часть тривиальных задач и упрощающий работу с источниками данных. В качестве источников данных могут использоваться как стандартные реляционные базы данных, так и NoSQL-хранилища вроде MongoDB или Redis.  
Spring Data - это проект, управляемый Spring, который направлен на обеспечение согласованного уровня доступа к данным для различных хранилищ данных, от реляционных баз данных до баз данных без sql.  
Spring Data НЕ является спецификацией или стандартом . Данные Spring - это абстракция . Это зонтичный проект, в котором есть несколько модулей (например, spring-data-redis, spring-data-mongo и т. Д.) И основной модуль, называемый spring-data-commons. Эта абстракция пытается обеспечить согласованность между способами доступа к данным в нескольких хранилищах данных.

В мире Java EE стандартом дефакто для работы с базами данных является JPA (Java Persistence API). Spring Data JPA, будучи частью Spring Data, реализует взаимодействие с реляционными СУБД, основываясь на JPA.

## Основные модули
Spring Data Commons - основные концепции Spring, лежащие в основе каждого модуля Spring Data.

Spring Data JDBC - поддержка репозитория Spring Data для JDBC.

Spring Data JDBC Ext - Поддержка расширений стандартного JDBC для конкретных баз данных, включая поддержку быстрого переключения при отказе соединения Oracle RAC, поддержку AQ JMS и поддержку использования расширенных типов данных.

Spring Data JPA - поддержка репозитория Spring Data для JPA.

Spring Data KeyValue - на Map основе хранилища и модули SPI легко построить модуль Spring данных для значения ключа магазинов.

Spring Data LDAP - поддержка репозитория Spring Data для Spring LDAP .

Spring Data MongoDB - основанная на Spring объектно-документационная поддержка и репозитории для MongoDB.

Spring Data Redis - Простая настройка и доступ к Redis из приложений Spring.

Spring Data REST - экспортирует репозитории Spring Data как ресурсы RESTful, управляемые гипермедиа.

Spring Data для Apache Cassandra - Простая настройка и доступ к Apache Cassandra или крупномасштабным высокодоступным приложениям Spring, ориентированным на данные.

Spring Data для Apache Geode - Простая настройка и доступ к Apache Geode для высоконадежных, ориентированных на данные приложений Spring с низкой задержкой.

Spring Data для Pivotal GemFire - Простая настройка и доступ к Pivotal GemFire ​​для ваших согласованных, ориентированных на данные приложений Spring с низкой задержкой / высокой пропускной способностью.

## Spring Data JPA

Spring Data JPA  является одним из многих  Spring Data  проектов и направлено в направлении обеспечения согласованности в доступе к данным для реляционных хранилищ данных. Многие люди считают Spring Data JPA реализацией JPA. На самом деле это ложь. Spring Data JPA использует реализацию JPA по умолчанию, называемую Hibernate . Реализация JPA по умолчанию является настраиваемой, и при желании мы можем использовать и другие реализации.

### Что такое Spring Data JPA, если не реализация JPA?
Точнее говоря, Spring Data JPA - это надстройка для JPA. он предоставляет структуру, которая работает вместе с JPA и обеспечивает полную абстракцию на уровне доступа к данным в проекте.

Spring Data JPA включает в себя концепцию  репозиториев JPA  - набор  интерфейсов,  которые определяют методы запроса . Repository и Entity Bean представляют уровень DAO в приложении. Больше не нужно писать собственные запросы. Иногда нам нужно писать запросы или их часть, но это запросы JQL, а не собственные запросы к базе данных.

 ____
 
 Spring Data is a high level SpringSource project whose purpose is to unify and ease the access to different kinds of persistence stores, both relational database systems and NoSQL data stores.  
 Spring Data - это высокоуровневый проект SpringSource, целью которого является унификация и упрощение доступа к различным типам хранилищ постоянства, как системам реляционных баз данных, так и хранилищам данных NoSQL.
 
 
 ![alt-text](resources/SpringData.png)
 
 Со всеми типами постоянных хранилищ ваши репозитории (также известные как DAO или объекты доступа к данным) обычно предлагают операции CRUD (создание-чтение-обновление-удаление) для объектов одного домена, методов поиска, сортировки и разбивки на страницы. Spring Data предоставляет универсальные интерфейсы для этих аспектов (CrudRepository, PagingAndSortingRepository), а также конкретные реализации хранилища сохраняемости.
 
 Хотя объекты-шаблоны мощные, мы можем добиться большего. В репозиториях Spring Data вам нужно только написать интерфейс с методами поиска, определенными в соответствии с заданным набором соглашений (которые могут варьироваться в зависимости от типа используемого вами хранилища постоянства). Spring Data предоставит соответствующую реализацию этого интерфейса во время выполнения. Например:
 
 ```java
public interface UserRepository extends MongoRepository<User, String> { 
        @Query("{ fullName: ?0 }")
        List<User> findByTheUsersFullName(String fullName);

        List<User> findByFullNameLike(String fullName, Sort sort);
}
...

Autowired UserRepository repo;
```

# REST 

REST (от англ. Representational State Transfer — «передача состояния представления») — архитектурный стиль взаимодействия компонентов распределённого приложения в сети.

В широком смысле компоненты в REST взаимодействуют наподобие взаимодействия клиентов и серверов во Всемирной паутине. REST является альтернативой RPC.
 
В сети Интернет вызов удалённой процедуры может представлять собой обычный HTTP-запрос (обычно GET или POST; такой запрос называют «REST-запрос»), а необходимые данные передаются в качестве параметров запроса[2][3].
 
Для веб-служб, построенных с учётом REST (то есть не нарушающих накладываемых им ограничений), применяют термин «RESTful».
 
В отличие от веб-сервисов (веб-служб) на основе SOAP, не существует «официального» стандарта для RESTful веб-API. Дело в том, что REST является архитектурным стилем, в то время как SOAP является протоколом. Несмотря на то, что REST не является стандартом сам по себе, большинство RESTful-реализаций используют такие стандарты, как HTTP, URL, JSON и XML (но XML зачастую не принято использовать).

## Ресурс

Ресурс — это ключевая абстракция, на которой концентрируется протокол HTTP. Ресурс — это все, что вы хотите показать внешнему миру через ваше приложение. Например, если мы пишем приложение для управления задачами, экземпляры ресурсов будут следующие:

- Конкретный пользователь
- Конкретная задача
- Список задач

### URI ресурса

Когда вы разрабатываете RESTful сервисы, вы должны сосредоточить свое внимание на ресурсах приложения. Способ, которым мы идентифицируем ресурс для предоставления, состоит в том, чтобы назначить ему URI — универсальный идентификатор ресурса. Например:

- Создать пользователя: POST /users
- Удалить пользователя: DELETE /users/1
- Получить всех пользователей: GET /users
- Получить одного пользователя: GET /users/1

## Вот как обычно реализуется служба REST:
   
- Формат обмена данными: здесь нет никаких ограничений. JSON — очень популярный формат, хотя можно использовать и другие, такие как XML
- Транспорт: всегда HTTP. REST полностью построен на основе HTTP.
- Определение сервиса: не существует стандарта для этого, а REST является гибким. Это может быть недостатком в некоторых сценариях, поскольку потребляющему приложению может быть необходимо понимать форматы запросов и ответов. Однако широко используются такие языки определения веб-приложений, как WADL (Web Application Definition Language) и Swagger.

____

REST (RESTful) - это общие принципы организации взаимодействия приложения/сайта с сервером посредством протокола HTTP. Особенность REST в том, что сервер не запоминает состояние пользователя между запросами - в каждом запросе передаётся информация, идентифицирующая пользователя (например, token, полученный через OAuth-авторизацию) и все параметры, необходимые для выполнения операции.

Всё взаимодействие с сервером сводится к 4 операциям (4 - это необходимый и достаточный минимум, в конкретной реализации типов операций может быть больше):
1. получение данных с сервера (обычно в формате JSON, или XML)
2. добавление новых данных на сервер
3. модификация существующих данных на сервере
4. удаление данных на сервере

___
API, использующие протокол HTTP для передачи запросов и ответов, рассматриваются как «веб-сервисы». В случае веб-сервисов клиент, делающий запрос на ресурс, и сервер API, предоставляющий ответ, могут использовать любой язык программирования или платформу. Не имеет значения, какой ЯП или платформа будут использоваться, потому что запрос сообщения и ответ сделаны через общий веб-протокол HTTP.

Веб-протокол является частью прекрасного веб-сервисов: они независимы от языка и поэтому совместимы между различными платформами и системами. При документировании REST API не имеет значения, строят ли инженеры API с помощью Java, Ruby, Python или какого-либо другого языка. Запросы выполняются через HTTP, и ответы возвращаются через HTTP.

## SOAP

До того, как REST стал самым популярным веб-сервисом, SOAP (Simple Object Access Protocol) был гораздо более распространенным. Чтобы лучше понять REST, полезно иметь некоторое понимание SOAP. Заодно и увидеть, что отличает SOAP и REST.

SOAP - это стандартизированный протокол, который требует XML в качестве формата сообщений для запросов и ответов. Как стандартный протокол, формат сообщения обычно определяется с помощью файла WSDL (язык описания веб-служб).

Файл WSDL определяет разрешенные элементы и атрибуты в обмениваемых сообщениях. Файл WSDL является машиночитаемым и используется серверами, взаимодействующими друг с другом для облегчения связи.

Сообщения SOAP заключены в «конверт», который включает в себя заголовок и тело, используя определенную схему XML и пространство имен. Пример формата запроса и ответа SOAP см. SOAP против REST 101: понимание различий.

Основная проблема с SOAP заключается в том, что формат сообщений XML слишком многословный и тяжелый. Особенно это проблематично в мобильных сценариях, где размер файла и пропускная способность играют решающее значение. Многословный формат сообщения замедляет время обработки, что делает взаимодействия SOAP вялым.

SOAP по-прежнему используется в enterprise приложениях (особенно в финансовых учреждениях) со связью server-to-server, но в последние годы SOAP вымещается REST, особенно для API открытых сетей.

___

                                                                                                                                                                                                                                                                                                                                          
SOAP - простой протокол доступа к объектам - вероятно, наиболее известная из двух моделей.

SOAP в значительной степени полагается на XML и вместе со схемами определяет структуру обмена сообщениями с очень строгим контролем типов.

Каждая операция, предоставляемая службой, явно определяется вместе со структурой XML запроса и ответа для этой операции.

Каждый входной параметр аналогичным образом определяется и привязан к типу: например, целому числу, строке или другому сложному объекту. 

Все это кодифицировано на языке WSDL - описания веб-службы (или определения в более поздних версиях). WSDL часто объясняется как договор между поставщиком и потребителем услуги. С точки зрения программирования WSDL можно рассматривать как сигнатуру метода для веб-службы.      

## Критика SOAP

Хотя на первый взгляд WSDL может показаться отличным - он самодокументируется и содержит почти полную картину всего, что требуется для интеграции с сервисом, - он также может стать обузой.

Помните, что WSDL - это контракт между вами (поставщиком услуги) и каждым из ваших клиентов (потребителей услуги).

Изменения WSDL также означают изменения клиента.

Если вы хотите внести изменения в свой API, даже такие небольшие, как добавление необязательного параметра, WSDL должен измениться. И изменения WSDL также означают изменения клиентов - все ваши потребители должны перекомпилировать свое клиентское приложение с этим новым WSDL.

Это небольшое изменение значительно увеличивает нагрузку на команды разработчиков (по обе стороны коммуникации), а также на команды тестирования. По этой причине WSDL рассматривается как привязка к версии, и большинство провайдеров очень сопротивляются обновлению своего API.

Более того, хотя SOAP предлагает некоторую интересную гибкость, такую ​​как возможность передачи по любому транспортному протоколу, на самом деле никто не воспользовался большинством из них.

Благодаря развитию Интернета все, что имеет значение, работает через HTTP.

Есть новые достижения, но большинству из них мешает то, что маршрутизаторы инфраструктуры отказываются маршрутизировать нестандартный HTTP-трафик. Только подумайте: сколько времени мир пытается перейти на IPv6?

Определенно существует потребность в более легкой и гибкой модели.

В любой ситуации, когда размер передаваемого сообщения не имеет значения или где вы контролируете все от начала до конца, протокол SOAP почти всегда является лучшим ответом.

Это в первую очередь относится к прямому обмену данными между серверами, обычно используемым для внутреннего взаимодействия только в рамках одной компании.

Однако существует потребность в мире, в котором почти каждый человек на планете имеет несколько устройств с низким объемом памяти и малой вычислительной мощностью, постоянно подключенных к нескольким службам, определенно существует потребность в более легкой и гибкой модели.


## Особенности REST

- Как и SOAP, REST (Representational State Transfer) использует HTTP в качестве протокола передачи данных для запросов и ответов. Однако, в отличие от SOAP, REST является архитектурным стилем, а не стандартным протоколом. Вот почему REST API иногда называют RESTful API - REST - это общий стиль, которому следует API.
  
  API-интерфейс RESTful может не соответствовать всем официальным характеристикам REST, указанным доктором Роем Филдингом, который впервые описал эту модель. Следовательно, API являются «RESTful» или «REST-подобными». (Некоторые разработчики настаивают на использовании термина «RESTful», когда API не соответствует всем характеристикам REST, но большинство людей просто называют их «REST API»)
  
- В архитектурном стиле нет ограничений XML в качестве формата сообщения. API REST могут использовать любой формат сообщений, который хотят использовать разработчики API, включая XML, JSON, Atom, RSS, CSV, HTML и другие.

  Несмотря на разнообразие параметров формата сообщений, большинство API REST используют JSON (нотацию объектов JavaScript) в качестве формата сообщений по умолчанию. Они используют JSON, потому что он обеспечивает легкий, простой и более гибкий формат сообщений, который увеличивает скорость связи. Облегченная природа JSON также позволяет выполнять сценарии мобильной разработки и легок для парсинга в Интернете с помощью JavaScript.

- REST фокусируется на ресурсах, доступ к которым осуществляется через URL   

  Другой отличительной чертой REST является то, что API-интерфейсы REST фокусируются на ресурсах (то есть вещах, а не действиях) и способах доступа к ресурсам. Ресурсы, как правило, являются разными типами информации. Вы получаете доступ к ресурсам через URL (Uniform Resource Locators), так же как переход к URL-адресу в вашем браузере позволяет подключиться к информационному ресурсу. URL-адреса сопровождаются методом, который указывает, как вы хотите взаимодействовать с ресурсом.
  
  Общие методы включают GET (чтение), POST (создание), PUT (обновление) и DELETE (удаление). Конечная точка обычно включает параметры запроса, которые определяют более подробную информацию о представлении ресурса, который нужно увидеть. Например, можно указать (в параметре запроса) ограничение на отображение 5 экземпляров ресурса.Другой отличительной чертой REST является то, что API-интерфейсы REST фокусируются на ресурсах (то есть вещах, а не действиях) и способах доступа к ресурсам. Ресурсы, как правило, являются разными типами информации. Вы получаете доступ к ресурсам через URL (Uniform Resource Locators), так же как переход к URL-адресу в вашем браузере позволяет подключиться к информационному ресурсу. URL-адреса сопровождаются методом, который указывает, как вы хотите взаимодействовать с ресурсом.
                                                                                                                                                                                                                                                                                                                                            
- API REST не сохраняют состояния запроса, но ответы могут кэшироваться

  REST API не сохраняют свои состояния и могут кэшироваться. Отсутствие состояния означает, что каждый раз, когда вы обращаетесь к ресурсу через конечную точку, API предоставляет один и тот же ответ. Он не запоминает ваш последний запрос и не учитывает его при предоставлении нового ответа. Другими словами, нет ранее запомненных состояний, которые API учитывает при каждом запросе.
  
  Ответы могут кэшироваться для повышения производительности. Если кэш браузера уже содержит информацию, запрашиваемую в запросе, браузер может просто вернуть информацию из кэша вместо того, чтобы снова стучаться на сервер.
  
  Кэширование API REST аналогично кешированию веб-страниц. Браузер использует значение времени последнего изменения в заголовках HTTP, чтобы определить, нужно ли ему снова получать ресурс. Если содержимое не было изменено с момента последнего извлечения, вместо него можно использовать кэшированную копию. Кэширование увеличивает скорость ответа.
  
- API REST не используют файлы WSDL, но некоторые спецификации все же существуют

  Важным аспектом API REST, особенно в контексте документации, является то, что они не используют файл WSDL для описания элементов и параметров, разрешенных в запросах и ответах.
  
  Хотя и существует возможный файл WADL (Web Application Description Language), который можно использовать для описания API-интерфейсов REST, им используются редко, поскольку там неадекватно описываются все ресурсы, параметры, форматы сообщений и другие атрибуты API-интерфейса REST. , (Помните, что REST API - это архитектурный стиль, а не стандартизированный протокол.)
                    
## Критика REST

Небольшой размер и использование широко распространенного стандарта HTTP делает REST очень привлекательным вариантом для общедоступных API.
                    
В сочетании с JSON, который делает что-то вроде добавления необязательного параметра очень простым, делает его очень гибким и позволяет частые выпуски, не затрагивая ваших потребителей.
                    
Возможно, самым большим недостатком является WADL - необязательный и не имеющий некоторой необходимой информации. Чтобы устранить этот недостаток, на рынке есть несколько платформ, которые помогают документировать и создавать RESTful API, например Swagger , RAML или JSON-home . Swagger был подарен инициативе Open API Iniative и теперь называется OpenAPI (OAS). Перейдите на Swagger.io, где вы можете узнать больше об этом стандарте, спецификации и о том, как инструменты Swagger играют роль.
                                                                                                                                                                                                                                                                                                                                               
## Разница между SOAP и REST

Термин веб-API обычно относится к обеим сторонам компьютерных систем, взаимодействующих по сети: к службам API, предлагаемым сервером, а также к API, предлагаемому клиентом, таким как веб-браузер.

Серверная часть веб-API представляет собой программный интерфейс для определенной системы сообщений «запрос-ответ» и обычно называется веб-службой. Существует несколько моделей проектирования веб-сервисов, но две наиболее распространенные - это SOAP и REST.

SOAP предоставляет следующие преимущества по сравнению с REST:

- Независимость от языка, платформы и транспорта (REST требует использования HTTP)     
- Хорошо работает в распределенных корпоративных средах (REST предполагает прямую связь точка-точка)
- Стандартизированный
- Обеспечивает значительную расширяемость перед сборкой в ​​форме стандартов WS *
- Встроенная обработка ошибок
- Автоматизация при использовании с определенными языковыми продуктами

REST по большей части проще в использовании и более гибок. Он имеет следующие преимущества по сравнению с SOAP:

- Использует простые для понимания стандарты, такие как swagger и OpenAPI Specification 3.0.
- Меньшая кривая обучения
- Эффективность (SOAP использует XML для всех сообщений, REST в основном использует меньшие форматы сообщений, такие как JSON)
- Быстро (не требуется обширной обработки)
- Ближе к другим веб-технологиям в философии дизайна

### Примерчик

Как сказано в одном руководстве по REST API: SOAP похож на конверт, а REST - это просто открытка.

Конечно, открытку быстрее и дешевле отправить, чем конверт, но ее все равно можно обернуть чем-то другим, даже конвертом.

Вы также можете просто прочитать открытку, в то время как конверт требует нескольких дополнительных действий, таких как открытие или разворачивание, чтобы получить доступ к тому, что внутри
   
# REST Кратко 

Representational State Transfer = «представление данных в удобном для клиента формате»

- Все является ресурсами с уникальным идентификатором (URL)
- Все операции клиента с сервером stateless, т.е. сервер не должен хранить вообще никакой информации о клиенте – никакой сессии
- Все запросы можно поделить на 4 типа в соответствии с CRUD, причем каждому типу сопоставляется HTTP метод – Post, Get, Put и Delete
- Вся логика крутится вокруг ресурсов, а не операций

## Принципы 

Важно понимать, что REST – это не протокол и не стандарт, а архитектурный стиль. У этого стиля есть свои принципы. Позволю себе скопировать их с понравившегося источника и прокомментировать:

- Give every “thing” an ID.  
  Очччень желательно.
  
- Link things together.  
  Например, в страницу (представление) о Mercedes C218 хорошо бы добавить ссылку на страницу конкретно о двигателе данной модели, чтобы желающие могли сразу туда перейти, а не тратить время на поиск этой самой страницы.
  
- Use standard methods.  
  Имеется в виду, экономьте свои силы и деньги заказчика, используйте стандартные методы HTTP, например GET
  http://www.example.com/cars/00345
  для получения данных вместо определения собственных методов вроде getCar?id=00345.
  
- Resources can have multiple representations.  
  Одни и те же данные можно вернуть в XML или JSON для программной обработки или обернутыми в красивый дизайн для просмотра человеком.
  
- Communicate statelessly.  
  Да, RESTful сервис должен быть как идеальный суд – его не должно интересовать ни прошлое подсудимого (клиента), ни будущее – он просто выносит приговор (отвечает на запрос).
  
## Сравнение SOAP и REST

1. SOAP – это целое семейство протоколов и стандартов, откуда напрямую вытекает, что это более тяжеловесный и сложный вариант с точки зрения машинной обработки. Поэтому REST работает быстрее.
2. SOAP используют HTTP как транспортный протокол, в то время как REST базируется на нем. Это означает, что все существующие наработки на базе протокола HTTP, такие как кеширование на уровне сервера, масштабирование, продолжают так же работать в REST архитектуре, а для SOAP необходимо искать другие средства. Взамен этого SOAP сервисы получают такое мифическое свойство, как возможность работать с любым протоколом транспортного уровня вместо HTTP, однако практической пользы от него зачастую не больше, чем сотрудникам Челябинского трубопрокатного завода от большого количесва статей в википедиях на мертвых языках.
3. Есть мнение, что разработка RESTful сервисов намного проще. Наверное, это правда, если использовать Notepad в качестве основной среды разработки, но вот с использованием наших чудесных средств разработки, я позволю себе усомниться в верности этого утверждения.
4. В первом гугловском результате по запросу «REST vs SOAP» акцентируется внимание на том, что ответ REST может быть представлен в различных форматах, а SOAP привязан к XML. Это действительно важный фактор, достаточно представить себе вызов сервиса из javascript, ответ на который мы определенно хотим получать в JSON.
5. «REST vs SOAP» можно перефразировать в «Простота vs Стандарты», что проявляется в том, что для SOAP мы имеем протокол WSDL для исчерпывающего описания веб-сервиса, который с использованием все тех же чудесных средств разработки прото-таки волшебным образом делает почти всю работу за нас. Со стороны REST мы имеем загадочный и неиспользуемый протокол WADL, который, в принципе, и не нужен – он мешает простоте.
6. Второй аспект предыдущего пункта – обработка ошибок. В SOAP она полностью стандартизована, а REST может использовать давно известные коды ошибок HTTP (если здесь Вас посетила мысль, что это же очевидно и зачем я это пишу, то значит Вы внимательно читаете статью).
7. То, с чего можно было бы начать, но я припас напоследок. Это одна из ключевых мыслей. SOAP работает с операциями, а REST – с ресурсами. Этот факт в совокупности с отсутствием клиентского состояния у RESTful сервисов приводит нас к тому, что такие вещи как транзакции или другая сложная логика должна реализовываться «SOAP-но».

## Пример REST

Букмекерская контора заказала сервис для работы с футбольной статистикой. Пользовательский функционал – получить список матчей, получить детали о матче. Для редакторов – редактировать (Create, Edit, Delete) список матчей, редактировать детали матча. Для такой задачи однозначно надо выбирать подход REST и получать бенефиты от его простоты и естественности во взаимодействии с HTTP. Не нужны нам здесь SOAP-конверты, SOAP-главпочтамты и SOAP-авиапочта, которая может использовать любую марку самолета

## Пример SOAP

Та же букмекерская контора захотела API для ставок на live матчи. Эта процедура включает в себя многочисленные проверки, например, продолжает ли ставка быть актуальной, не изменился ли коэффициент, не превышена ли максимальная сумма ставки для маркета. После этого происходит денежная транзакция, результаты которой записываются в основную и в резервные базы данных. Лишь после этого клиенту приходит ответ об успешности операции. Здесь явно прослеживается ориентация на операции, имеются повышенные требования к безопасности и устойчивости приложения, поэтому целесообразно использовать SOAP.

## Выводы
Филдинг со своими принципами REST ничего не изобрел, а просто собрал в одну диссертацию то, что уже существовало в каком-то виде и изложил то, как можно получать максимальную выгоду из уже сформировавшейся архитектуры сети.

SOAP и REST – не конкуренты. Они представляют разные весовые категории и вряд ли найдется задача, для которой будет сложно сказать, какой подход рациональнее использовать – SOAP или REST. Поэтому «религиозные» убеждения в вопросах выбора архитектуры для веб-сервиса вряд ли будут полезны. Для тех, кто не знает, с чего начать анализ задачи, могу
                    
REST против SOAP можно перефразировать как “Простота против Стандарта”. В случае REST (простота) у вас будет скорость, расширяемость и поддержка многих форматов. В случае с SOAP у вас будет больше возможностей по безопасности (WS-security) и транзакционная безопасность (ACID).
                    
## JAX-WS и JAX-RS

JAX-WS -is Java API для XML-Based Web Services-стандартный способ разработки Web-сервисов в нотации SOAP (Simple Object Access Protocol).

Вызов веб-служб осуществляется с помощью удаленных вызовов процедур. Для обмена информацией между клиентом и веб-сервисом используется протокол SOAP. Обмен сообщениями между клиентом и сервером осуществляется через XML - основанные SOAP сообщения.

Клиенты веб-службы JAX-WS нуждаются в файле WSDL для генерации исполняемого кода, который клиенты могут использовать для вызова веб-службы.

JAX-RS -Java API для веб-служб RESTful. RESTful веб-службы представлены как ресурсы и могут быть идентифицированы с помощью унифицированных идентификаторов ресурсов ( URI ). Удаленный вызов процедуры в этом случае представляется HTTP-запросом и необходимые данные передаются в качестве параметров запроса. Веб-сервисы RESTful-более гибкие, могут использовать несколько различных MIME - типов. Обычно используется для обмена данными XML или JSON (обозначение объекта JavaScript)...

## RPC и REST

- RPC API думает в терминах «глаголы», обнажая функциональность ресторана , как вызовы функций , которые принимают параметры, и вызывает эти функции с помощью HTTP глагол , который кажется наиболее подходящим - это «получить» для запроса, и так далее, но имя глагола является чисто случайным и не имеет реального отношения к реальной функциональности, поскольку вы каждый раз вызываете другой URL-адрес . Коды возврата кодируются вручную и являются частью контракта на обслуживание.

- REST API , в отличии от модели различных объектов в пределах проблемной области как ресурсы и использование HTTP глаголов для представления операций против этих ресурсов - POST для создания, PUT для обновления и GET для чтения. Все эти команды, вызываемые по одному и тому же URL-адресу , обеспечивают разную функциональность. Общие коды возврата HTTP используются для передачи статуса запросов.

## RPC и SOAP

Во-первых, очевидно, что дизайн отличается. Структурная архитектура SOAP более сложна по сравнению с RPC. Он содержит сообщения XML , которые преобразуются с помощью SOAP-Envelope. RPC, с другой стороны, использует XML как для кодирования, так и для декодирования вызовов удаленных процедур в пределах своих параметров. У него более простая архитектура по сравнению с SOAP.

Во-вторых, в SOAP порядок не имеет значения, и процедуры в основном принимают именованные параметры. В XML-RPC все наоборот. Порядок имеет значение, и процедуры не должны принимать именованные параметры.

SOAP считается более мощным; со спецификациями 1.2 умещается на 44 страницы, а RPC умещается на 6 страницах.  
Также следует учитывать, что протокол SOAP, как известно, более подробен, но зачастую более эффективен, чем RPC. Однако с точки зрения поддержки python в стандартной библиотеке RPC значительно поддерживается по сравнению с SOAP.

## Когда выбирать REST и SOAP

Теперь имейте в виду, что использование SOAP 1.2 сопряжено с некоторыми дополнительными накладными расходами, которых нет в подходе REST, но эти накладные расходы также имеют преимущества. Во-первых, SOAP использует XML (расширяемый язык разметки) тремя способами; Конверт - определяет, что находится в сообщении и как его обрабатывать, набор правил кодирования для типов данных и, наконец, макет собранных вызовов процедур и ответов. Этот конверт отправляется через транспорт (HTTP / HTTPS), выполняется RPC (удаленный вызов процедуры), и конверт возвращается с информацией в документе в формате XML.

Важно отметить, что одним из преимуществ SOAP является использование «универсального» транспорта. В то время как REST сегодня использует HTTP / HTTPS, SOAP может использовать практически любой транспорт для отправки запроса, используя все, от вышеупомянутого до SMTP (Simple Mail Transfer Protocol) и даже JMS (Java Messaging Service). Однако одним очевидным недостатком является использование XML из-за его многословности и времени, необходимого для анализа.

Но неописуемая история заключается в том, что обе технологии можно смешивать и сочетать. REST очень прост для понимания и чрезвычайно доступен, но ему не хватает стандартов и он считается архитектурным подходом. Для сравнения: SOAP - это отраслевой стандарт с четко определенным протоколом и набором четко установленных правил, которые необходимо реализовать, и он используется как в больших, так и в малых системах.

### Когда выбирать REST

Это означает, что REST действительно хорошо работает в следующих областях:

- Ограниченная пропускная способность и ресурсы; помните, что структура возврата действительно в любом формате (определенном разработчиком). Кроме того, можно использовать любой браузер, потому что подход REST использует стандартные команды GET , PUT , POST и DELETE . Опять же, помните, что REST также может использовать объект XMLHttpRequest, который сегодня поддерживают большинство современных браузеров, что добавляет дополнительный бонус AJAX.

- Операции без сохранения состояния; если операцию необходимо продолжить, тогда REST - не лучший подход, и SOAP может подойти ему лучше. Однако, если вам нужны операции CRUD без сохранения состояния (создание, чтение, обновление и удаление), тогда REST - это то, что вам нужно.

- Кеширование ситуаций; если информация может быть кэширована из-за полностью не имеющего состояния операции подхода REST, это прекрасно.

### Когда выбирать SOAP

Это охватывает множество решений из трех вышеупомянутых. Так зачем мне вообще рассматривать SOAP? Опять же, SOAP является достаточно зрелым и четко определенным и поставляется с полной спецификацией. Подход REST - это всего лишь подход, который широко открыт для разработки, поэтому, если у вас есть следующее, SOAP - отличное решение:

- Асинхронная обработка и вызов; если вашему приложению требуется гарантированный уровень надежности и безопасности, то SOAP 1.2 предлагает дополнительные стандарты для обеспечения такого типа работы. Такие вещи, как WSRM - надежный обмен сообщениями WS.

- Официальные контракты; если обе стороны (поставщик и потребитель) должны согласовать формат обмена, тогда SOAP 1.2 дает жесткие спецификации для этого типа взаимодействия.

- Операции с отслеживанием состояния ; если приложению требуется контекстная информация и управление диалоговым состоянием, тогда SOAP 1.2 имеет дополнительную спецификацию в структуре WS * для поддержки этих вещей (безопасность, транзакции, координация и т. д.). Для сравнения, подход REST заставил бы разработчиков построить эту нестандартную сантехнику.


