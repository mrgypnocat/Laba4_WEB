# Laba4_WEB

Будет больно, но ради этого и живем

- [ ] Уровень back-end должен быть основан на JavaEE (необходимо использовать EJB)
- [ ] Уровень front-end должен быть построен на React + Redux (необходимо использовать ES6 и JSX) с использованием набора компонентов React Toolbox
- [ ] Взаимодействие между уровнями back-end и front-end должно быть организовано посредством REST API

Приложение включает в себя две страницы: стартовую и основную. Обе страницы должны быть адаптированы для отображения в 3 режимах:
- [ ] "Десктопный" - для устройств, ширина экрана которых равна или превышает 1169 пикселей 
- [ ] "Планшетный" - для устройств, ширина экрана которых равна или превышает 708, но меньше 1169 пикселей 
- [ ] "Мобильный" - для устройств, ширина экрана которых меньше 708 пикселей 
    
Стартовая страница должна содержать следующие элементы:
- [x] "Шапку", содержащую ФИО студента, номер группы и номер варианта
- [x] Форму для ввода логина и пароля 
- [ ] Информация о зарегистрированных в системе пользователях должна храниться в отдельной таблице БД 
- [ ] Пароль должен храниться в виде хэш-суммы
- [ ] Доступ неавторизованных пользователей к основной странице приложения должен быть запрещен 

Основная страница приложения должна содержать следующие элементы:
- [x] Набор полей ввода для задания координат точки и радиуса области в соответствии с вариантом задания:
    - [x] Dropdown {'-4','-3','-2','-1','0','1','2','3','4'} для координаты по оси X
    - [x] Input (-3 ... 5) для координаты по оси Y
    - [x] Dropdown {'-4','-3','-2','-1','0','1','2','3','4'} для задания радиуса области 
- [x] Если поле ввода допускает ввод заведомо некорректных данных (таких, например, как буквы в координатах точки или отрицательный радиус), то приложение должно осуществлять их валидацию 
- [ ] Динамически обновляемую картинку, изображающую область на координатной плоскости в соответсвии с номером варианта и точки, координаты которых были заданы пользователем.
- [ ] Клик по картинке должен инициировать сценарий, осуществляющий определение координат новой точки и отправку их на сервер для проверки ее попадания в область. 
- [ ] Цвет точек должен зависить от факта попадания/непопадания в область
- [ ] Смена радиуса также должна инициировать перерисовку картинки
- [ ] Таблицу со списком результатов предыдущих проверок
- [ ] Ссылку, по которой аутентифицированный пользователь может закрыть свою сессию и вернуться на стартовую страницу приложения
 
Дополнительные требования к приложению:

- [ ] Все результаты проверки должны сохраняться в азе данных под управлением СУБД PostgreSQL 
- [ ] Для доступа к БД необходимо использовать JPA

# Вопросы к защите лабораторной работы

## 1. Платформа Java EE. Спецификации и их реализации.

Java EE — это платформа, построенная на основе Java SE, которая предоставляет API и среду времени выполнения для разработки и запуска крупномасштабных, многоуровневых, масштабируемых, надежных и безопасных сетевых приложений.

Подобные приложения называют корпоративными (Enterprise applications), так как они решают проблемы, с которыми сталкиваются большие бизнесы. 

Java EE представляет из себя набор спецификаций и документации, описывающий архитектуру серверной платформы для задач средних и крупных предприятий.
Сервер приложений Java EE (часто называемый контейнером) — это реализация системы в соответствии со спецификацией, обеспечивающая работу модулей с логикой конкретного приложения.

Деление на платформы (Java SE, Java EE, Java Card ...) появилось в Java EE 6 и позволяет сделать более «лёгкими» приложения, которым не нужен полный стек технологий Java EE. Существует только 2 профиля — Full и Web. 	Сервер приложений может реализовывать спецификации не всей платформы, а конкретного профиля.

Однако, Java EE может работать в общем случае только в рамках Enterprise Application Server’a (Tomcat таковым не является), а приложение на Spring стеке может работать на чем угодно (на том же Tomcat), и даже вообще без сервера (так как запустит его внутри себя самостоятельно).

Это делает Spring идеальным инструментом для разработки небольших приложений с GUI на Front-end или для микросервисной архитектуры. Но отказ от зависимости от серверов приложений отрицательно сказался на масштабируемости Spring-приложений.

А Java EE хорошо подходит для реализации масштабируемого монолитного кластерного приложения.


Пример Web profile: Tomcat

Пример Full profile: Glassfish

https://javarush.ru/groups/posts/2637-vvedenie-v-java-ee - классное объяснение 


## 2. Принципы IoC, CDI и Location Transpanency. Компоненты и контейнеры.

Приложение состоит из компонентов и контейнера, управляющего жизненным циклом компонентов. Пример: Servlet - компонент, Glassfish - контейнер.

Есть такая штука - JNDI - набор API, позволяющий доставать объекты из контейнера по их именам. По сути, это замена обращению по ссылкам, и благодаря этому легко реализуется Dependency Lookup и Dependency Injection. Хранение объектов в таком случае можно представить как Map, где ключи - это имена, а значения - нужные объекты (например, ссылки на них).

### Inversion of Control: 

Объекты создает не программист (используя new), а контейнер IoC. Применяется далеко не ко всем объектам в приложении, а только к  управляемым (в Spring это классы с аннотациями @Component, @Service и т.д., в EJB — бобы @Stateless, @Stateful, @MessageDriven).

Контейнер не только создает объекты, но полностью управляет их жизненным циклом, вызывая на определенных этапах callback методы.

### Dependency injection (реализуется с помощью аннотаций):

Вместо построения зависимостей в компоненте, где они нужны:
public class Something {
  private Dependency dependency = new Dependency()
}

Мы принимаем их извне, что избавляет компонент от необходимости управлять ими:
public class Something {
  private Dependency dependency;

  public Something (Dependency dependency) {
    this.dependency = dependency;
  }
} 
Чтобы нам не пришлось вручную собирать все зависимости для создания компонентов, контейнер IoC предоставляет возможность внедрения инстанций в поля, помеченные специальной аннотацией:
public class SomethingDI {
  @Autowired private Dependency dependency; // Spring
  @EJB private EjbDependency ejbDependency; // EJB
}


## 3. Управление жизненным циклом компонентов. Дескрипторы развёртывания.
## 4. Java EE API. Виды компонентов. Профили платформы Java EE.
## 5. Компоненты EJB. Stateless & Stateful Session Beans. EJB Lite и EJB Full.
## 6. Работа с электронной почтой в Java EE. JavaMail API.
## 7. JMS. Реализация очередей сообщений. Способы доставки сообщений до клиента. Message-Driven Beans.
## 8. Понятие транзакции. Управление транзакциями в Java EE. JTA.
## 9. Веб-сервисы. Технологии JAX-RS и JAX-WS.
## 10. Платформа Spring. Сходства и отличия с Java EE.
## 11. Модули Spring. Архитектура Spring Runtime. Spring Security и Spring Data.
## 12. Реализация IoC и CDI в Spring. Сходства и отличия с Java EE.
## 13. Реализация REST API в Java EE и Spring.
## 14. React JS. Архитектура и основные принципы разработки приложений.
## 15. Компоненты React. State & props. "Умные" и "глупые" компоненты.
## 16. Разметка страниц в React-приложениях. JSX.
## 17. Навигация в React-приложениях. ReactRouter.
## 18. Управление состоянием интерфейса. Redux.
## 19. Angular: архитектура и основные принципы разработки приложений.
## 20. Angular: модули, компоненты, сервисы и DI.
## 21. Angular: шаблоны страниц, жизненный цикл компонентов, подключение CSS.
## 22. Angular: клиент-серверное взаимодействие, создание, отправка и валидация данных форм.

## Вопросы к себе

1) Зачем export default в файлах js
2) Отличие react-router от react-router-dom
3) When using Webpack you need to require images in order for Webpack to process them, which would explain why external images load while internal do not, so instead of <img src={"/images/resto.png"} /> you need to use <img src={require('/images/image-name.png')} /> replacing image-name.png with the correct image name for each of them. That way Webpack is able to process and replace the source img.
4) rest easy что це такое
5) Лучше деплоить вместе или раздельно 

